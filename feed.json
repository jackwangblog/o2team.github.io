{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Mon, 26 Dec 2016 12:25:57 GMT","lastBuildDate":"Thu, 29 Dec 2016 07:45:59 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"京东2016版首页改版前端总结","link":"https://aotu.io/notes/2016/12/26/jd-index-2016-summary/","description":"深圳的天气总是多变，前一段时间还是凉意浓浓，似乎要步入冬天了，最近却又变得炎热起来，气温骤升，让人措手不及。正如我们负责的业务一样，一年下来有诸多变化。今年9月份我们接手了京东2016版首页改版开发，历经1个多月紧张地开发测试，终于在双11前成功全量发布，回想整个开发历程，感觉还是有很多值得思索的地方，例如北京一月，虽然日夜颠倒，加班不止，但整个人居然胖了许多，不禁让人匪夷所思。 整体架构最初听说要做新版京东首页的时候，是怀有一丝惶恐的，毕竟是作为京东的门户，其重要性和受关注程度自然不言而喻，一行代码的失误可能会造成不可挽回的后果，而且过去的首页无论性能，还有体验在业界都已经是做得非常优秀了，要再想有些出彩的地方，也是十分困难，所以综上就是压力山大。当然，花开两朵，咱们单表一枝，本文主要还是相对这次改版工作中提炼的工作方法和优化方式做出一定的总结。 这次改版，在前端架构上大体还是沿用过去的架构，使用 jQuery + Seajs 这种古老的开发方式，因为首页还依赖着许多旧的系统与组件，无法在短时间内对基础架构进行升级，当然并不是说旧的就不好，要去盲目追求一些新的东西，而是这种架构还是有可以提升的地方。 而整个项目的架构是经历之前业务进行总结提炼出来的 Athena前端工程化工具，是我们团队自己探索开发的一套基于NodeJs的命令行式前端工程化工具，解决了自动化编译、代码处理、依赖分析、文件压缩等前端开发中的常规问题，有效地提升了我们的工作效率，解放生产力，目前已经应用于我们团队的多个业务中，首页改版也使用Athena来进行开发； Athena管理平台，是Athena工具配套的管理后台，它会收集本地工具操作中上报的统计数据，包括项目、模块、页面、组件创建的信息，文件、资源依赖关系的信息等，通过这些数据来进行项目和资源的管理，同时提供了项目模板，方便使用本地工具创建项目时选择，具体可以参考之前的博文我们是如何做好前端工程化和静态资源管理； Athena组件平台，是基于Athena总结的一套业务组件的平台，可以很好地管理我们的业务组件，方便组件的复用和传播； Athena基础库及组件库，是业务中总结出的基于jQuery + Seajs的js库，简化业务开发，提供完整的框架； Athena模拟接口，可以自由编辑生成指定接口的假数据，用于开发时真实接口的替代，让开发不再依赖后端接口； Athena兜底接口服务，可以指定接口生成一份兜底数据接口，平台会定时去抓取指定接口数据，然后生成兜底数据到CDN，从而生成对应的兜底接口，这样让正常接口多一份兜底保障； Athena前端监控，通过在页面中进行埋点上报的方式，我们可以在监控系统中，实时地看到性能相关数据。我们进行上报的不止有页面性能、速度相关的数据，同时会上报用户的环境信息，例如操作系统、浏览器、网速等，而且还会对页面中错误信息进行上报，如模块的隐藏等，通过这些数据，对我们的业务进行实时地监控与分析。 在我们的架构中，各种各样的工具与系统相辅相成，覆盖到了开发到上线的各个环节，自成一套体系。这样的架构不止是针对首页这个业务的，而是在基于对之前业务开发总结的基础上进行完善、调整的架构，适用于我们各个业务。而这次首页的改版中，我们对开发模式、性能优化、体验优化都进行了一些新的探索，让我们对于业务开发的整体解决方案又有了新的改进。 开发模式Athena开发效率的提升是我们一直追求的，工欲善其事，必先利其器，我们通过总结以往的开发工作，提出了各种手段来优化我们的开发效率，前端工具Athena就是其中的一个产物，当然它又不仅仅是为了提升开发效率而已，它是我们总结出的一套针对前端开发的完整解决方案，可以让我们的整体开发流程更加简单明了。 Athena提供了统一的项目架构，根据业务功能不同，我们将一个项目(app)拆分成不同的业务模块(module)，而每一个模块都包含自身的页面(page)以及构成页面所需要的组件(widget)。 在本地使用Athena创建完整的项目结构，随后我们就可以只关注代码逻辑的书写，Athena提供了简便的操作命令可以一键式地实时编译预览我们的页面，从而让我们不必去关心文件处理、代码编译等细节，开发完后，可以通过Athena执行完整的编译步骤并同步到我们的服务器上方便进行浏览测试。 使用Athena，新版首页开发模式大致如下： 前后端分离基于Athena工具，我们目前已经可以做到完全地本地开发调试了，但是还并不能做到完全的前后端分离，以过去首页为例，页面被拆分成首屏和楼层，首屏采用直出的方式以提升速度，楼层则使用异步加载的方式，拉取服务器上已经渲染好的HTML字符串，如图 整个页面，包括首屏和楼层，都需要前端写好静态HTML，然后给后端开发同学来套用，转成后端语言对应的模板，这样导致前后端耦合较深，HTML更新极不方便，开发成本较高。 为了解决这样前后端耦合的问题，减少沟通成本，这次首页改版我们使用了新的开发方式，为了保证首屏速度，首屏依然采用直出的方式，但对非首屏的楼层进行改进，使用前端模板 + 数据开发方式，将DOM字符串的渲染放到前端来做，后端只提供数据接口，以此来达到前后端分离的效果，同时在开发中使用假数据平台模拟接口，让前端工作不再依赖后端。 在最开始提出这样前后端分离方案的时候还是受到了不少的质疑，因为使用前端模板 + 数据开发方式，会使得每个楼层都多一个接口，并且需要依靠JS来动态渲染，会影响到楼层加载的性能，但经过我们的测试证明在现代PC浏览器下两种模式前端渲染和后端渲染并不会相差太多，并且在模板、数据双重缓存下，这样的差距更是微乎其微了，更关键的是能让我们的开发效率有所提升。 当然，我们对于性能的追求总是孜孜不倦，为了让楼层的加载速度更快，减少请求，我们在后续将使用在服务端定时获取数据编译前端模板，然后生成静态文件推送到CDN的方式来改进，和之前的由后端开发同学套模板生成静态文件不同的是，我们将自己搭建这样的中间层服务，在服务端编译前端模板，实现前后端同构，而前端可以随时切换渲染方式，改成请求渲染好的 HTML 字符串来进行加载，以此来提升性能。 对性能优化的探索性能永远是前端工程师追求的主题，过去首页在性能优化上已经做得非常极致了，它已经使用了各种手段来优化性能，包括首屏直出、样式直出来提升首屏速度，楼层按需加载，减少不必要的请求等等，所以在做新版首页的时候，我们感觉战战兢兢，因为改版不能让页面受到影响，而且最好还能比原来更快，所以，这次改版中我们主要通过如下手段来进行性能的优化。 首屏直出和精简首屏直出是让首屏速度更快的最佳选择，此次版本依然选择了首屏直出的方式，直出的内容包括首屏HTML，页面楼层骨架，以及样式和一些必须的脚本，看起来和之前的方式如出一辙，但此次改版我们还是做了很大的改进，那就是让首屏更加精简。 过去是将页面引用的所有样式都直出在页面上，没有外链的CSS，各种优化手段都考虑进去了，那么新版首页就只能在精简大小上下功夫了，所以新版首页的首屏只直出了首屏必须的样式，同时只直出一小部分必须的脚本，而非首屏的楼层样式拆分到各自楼层中，和楼层的模板放在一起，按需加载。 通过对Athena工具的改造，我们实现样式、模板的统一抽离这一功能，并且是在项目编译阶段自动实现的，开发者勿需关心。由于Athena统一的项目结构，每一个楼层在我们的项目中对应一个widget的组件，组件包含自己的HTML 、CSS、 JavaScript文件，同时widget的组件是可以继续调用其他widget的组件的，所以在编译时，工具会自动分析所有widget的依赖关系，然后把楼层的模板和所有引用到样式打包到一个文件中。最后在楼层加载的时候去请求这个文件，然后解析加载。这样的抽离工作会在最后的项目编译阶段进行，而进行本地开发预览的时候并不会执行，这样保证了开发的效率。 1234567// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.jsjsonCallBack_rec_tpl(&#123; dom: '&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ', style: \".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\", time: 1479195351434, version: \"ff78610a0ef9cdbb\"&#125;); 通过上述手段，我们让首屏变得更加精简，从下面的对比中就可以看出 这是过去首页首屏大小 这是新版首页首屏大小 可以看出优化精简之后，新版的首屏的大小减小了非常之多。 首屏轮播第一帧直出一直以来轮播都是靠页面最后加载的JS来进行渲染的，因为轮播图有随机渲染图片的逻辑需要依赖JS，但在一段时间的观察之后发现，如果CDN出现抖动，或者用户的网速较慢，那么首屏轮播这一块位置就会一直空着，给人的体验非常不好 所以在这一版的首页中我们将轮播图第一帧的数据直出在页面上，同时也将第一帧的渲染逻辑也直出在页面上，这样一来，首屏轮播出来得就非常快，减少用户的等待时间。 楼层按需加载与滚动优化首屏直出后，非首屏的内容肯定也不会一次性全部加载，因为像首页这样的页面楼层非常之多，一次性加载全部不仅仅慢，而且对接口来说也是一种损耗，所以我们考虑将楼层按需加载。 在我们新的方案中，已经采用了前端模板+数据的开发模式，所以在开发中我们想用直接书写前端模板的方式来进行开发，然后在本地进行预览，而在项目编译时能将我们的模板编译成独立的文件，方便渲染逻辑进行加载。所幸Athena工具已经支持了这样的功能，在开发中我们以编写前端模板的方式去开发整个页面，随后通过编译工具，在代码编译阶段自动将楼层的模板和样式抽离成一个与组件同名的独立JS文件，通过页面加载逻辑去按需拉取模板文件，再进行渲染。 下面例子揭示了楼层模板生成的过程 直接书写前端模板，编写模板时我们给模板加上标记位 o2-out-tpl1234567891011121314151617181920212223&lt;script type=\"text/template\" class=\"o2template\" o2-out-tpl&gt; &#123;% var i, clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag; var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion; %&#125; &#123;% var len = o.list.length; len = Math.min(len, 3); %&#125; &#123;% if (len &gt;= 1) &#123; %&#125; &lt;div class=\"grid_c1 rec_inner\"&gt; &lt;ul class=\"rec_list\"&gt; &#123;% for(i = 0; i &lt; len; i++)&#123; %&#125; &#123;% var item = o.list[i]; %&#125; &#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125; &lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt; &lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + 'a' + (i &lt; 9 ? '0' : '') + (1+i) %&#125;\"&gt; &lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt; &lt;/a&gt; &lt;/li&gt; &#123;% &#125; %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;% &#125; %&#125;&lt;/script&gt; 在编译时扫描依赖关系，生成模板JS文件依赖组件的关系表1234567891011121314151617181920212223242526272829303132333435\"dependency\": &#123; \"elevator_tpl.js\": [], \"entry_tpl.js\": [ &#123; \"widgetName\": \"spetit\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125; ], \"fbt_tpl.js\": [ &#123; \"widgetName\": \"find\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125;, &#123; \"widgetName\": \"brand\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125;, &#123; \"widgetName\": \"top\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125; ]&#125; 通过关系表去合并处理CSS样式，再和前端模板一起计算出MD5，生成独立的JS文件1jsonCallBack_rec_tpl(&#123;dom:'&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ',style:\".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\",time:1479466862559,version:\"ff78610a0ef9cdbb\"&#125;); 同时会在逻辑脚本入口位置自动加入模板的版本号123456789101112&#123; \"elevator_tpl\": \"e4d5dbaa3ecd12d2\", \"entry_tpl\": \"e3150fce4b2b332a\", \"fbt_tpl\": \"18f8bff18188a453\", \"floor_coupon_tpl\": \"1559694cb962e0d6\", \"floor_ract_tpl\": \"13b92d16fb6e2f7a\", \"mod_footer_tpl\": \"49142394d0e7f24e\", \"more_tpl\": \"d300081dd7f13f78\", \"portal_tpl\": \"68fae801a032cf93\", \"rec_tpl\": \"ff78610a0ef9cdbb\", \"seckill_tpl\": \"f11d04fd7eabc0e6\"&#125; 模板文件通过系统发布到CDN后，我们就需要有一套加载逻辑来进行加载。通过监听滚动事件，我们判断让处于浏览器视窗内的楼层进行加载，由于监听了滚动事件，为了让滚动更加流畅，我们必然要对滚动中做的操作进行优化。为了避免滚动操作不断被触发，需要对滚动进行节流处理。我们的原则是尽量避免在滚动的时候进行DOM操作与复杂计算，所以在渲染逻辑初始化的时候，我们就已经收集好了楼层的相关信息，包括楼层高度、楼层的offsetTop等，这样在滚动的时候就不再需要进行任何DOM操作了，让滚动的效率有所提升。而当楼层的数据例如楼层高度发生变化时，则通过消息通知的机制来实时地更新楼层信息即可。 脚本延后加载执行除了楼层是按需加载的，页面中用到的一些脚本文件也是尽量延后加载、执行。Athena工具在代码打包的时候，会对每个独立的文件进行单独处理，同时生成一份静态资源的线上对应表，在编译的最后会将引用的资源替换成配置的线上绝对地址。我们可以使用Seajs提供的require.asyncAPI来进行异步加载资源，这样让资源加载更加合理。 12345// 开发中的代码require.async(__uri('APP_JS_ROOT/header.js'))// 编译后require.async('//misc.360buyimg.com/mtd/pc/index/js/header.js') 同时，还有业务上一些统计上报等逻辑，可以放到 window onload 事件之后再执行，这样可以避免由于类似统计这样的请求占用到页面加载资源，从而降低页面 onload 时间。 模板、数据分离缓存每个楼层都按需加载之后，每次去加载这个楼层是否都要重新去请求这个楼层的模板和数据呢？答案当然是否定的。 目前大部分浏览器已经提供了许多前端缓存的解决方案，而其中兼容性最好，易用性最强的非localStorage莫属。利用localStorage我们可以对模板和数据进行缓存，这样当用户第二次加载的时候就可以不用再去请求网络资源，而可以直接从本地获取了。 但缓存之后如何进行更新呢？我们可以通过进行MD5校验版本来实现。 对数据来说，数据是由后端给出的，我们可以让后端同学将可以缓存的接口数据计算出一个MD5值作为版本号，然后直出在页面上，同时在接口中返回这个版本号，这样当前端去加载是首先判断版本号是否一致，以此来判断是直接读缓存还是从网络请求资源。 而对于模板来说，则可以通过Athena工具，在每次编译的时候自行计算出版本号，写入模板文件和入口JS文件中，这样在模板加载的时候也可以进行比对。 单个模板文件 1234567// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.jsjsonCallBack_rec_tpl(&#123; dom: '&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ', style: \".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\", time: 1479195351434, version: \"ff78610a0ef9cdbb\"&#125;); JS入口文件 1234567891011121314// https://misc.360buyimg.com/mtd/pc/index/home/index_focus.min.jswindow.tplVersion = &#123; \"1212_tpl\": \"ce7dcd7cd0beacb2\", elevator_tpl: \"e4d5dbaa3ecd12d2\", entry_tpl: \"2caa7cd543c322ea\", fbt_tpl: \"18f8bff18188a453\", floor_coupon_tpl: \"b98cf33be84aae98\", floor_ract_tpl: \"13b92d16fb6e2f7a\", mod_footer_tpl: \"072072ffc47778be\", more_tpl: \"25dcb060800c503a\", portal_tpl: \"68fae801a032cf93\", rec_tpl: \"ff78610a0ef9cdbb\", seckill_tpl: \"4fee56c5b073e5e1\"&#125;; 通过上述方式，我们实现了模板、数据的分离缓存，由于楼层类似的关系，页面中的模板大多数是重复，这样子模板缓存起来就能大大提高模板的利用率，当用户第二次访问的时候将不会再产生请求，在加速访问的同时，减少网络带宽消耗，并且如果数据发生更新，用户只需要更新数据即可，大大减少流量消耗。 大量使用WebP格式图片在这次改版中，很多的图片我们都使用了WebP格式来减小图片大小。 WebP格式，是谷歌开发的一种旨在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。但WebP的兼容性不太好，目前基本只有Chrome浏览器可以支持，不过这对我们的首页来说，使用WebP还是会有很大的收益，因为通过我们的统计数据可知，首页Chrome用户已经占到了60%左右。 体验优化探索在努力提升页面性能的同时，还要让页面的用户体验有所提升，这需要我们能站在用户和前端的角度提出合理的优化方案。 高清屏适配方案人类的社会在发展，人类的社会在进步，现如今高清分辨率屏幕的应用已经越来越多，高冷的Mac自不必说，现在许多新型号的Windows电脑也配备了高清分辨率的显示器，所以为了提升这一部分用户的浏览体验，我们需要在高清屏上启用高清素材。 但页面中素材图基本都是运营上传的，如果传两套图对运营来说未免太过麻烦，但如果只传一套高清图，直接展示的话对非高清屏没有必要，会造成流量损耗。这时候京东给力的图片服务就发挥作用了。 图片服务支持按一定规则改变URL来等比缩放图片，例如原图是一张800X340的图片 1//img13.360buyimg.com/cms/jfs/t3412/357/1332248120/113691/f29c2f1e/58244d4dN08b89f9e.jpg!q90.webp 我们可以通过这样设置来得到一样等比缩放400X170的图片 1//img13.360buyimg.com/cms/s400x170_jfs/t3412/357/1332248120/113691/f29c2f1e/58244d4dN08b89f9e.jpg!q90.webp 这样的话，运营同学只需要上传一张高清图片，我们通过判断是否高清屏，来动态改变URL，使用图片服务来得到一张等比缩放的非高清素材，而且CDN会根据图片URL进行缓存，也就是说只要第一次访问过缩放的图片就好，这样性能也不会有什么损耗。 强制webkit内核渲染很多国产浏览器都是双内核，例如360、QQ浏览器等，而它们都提供了强制使用Webkit内核渲染的开启方式，这样可以让用户获得更好的浏览体验。 1&lt;meta name=\"renderer\" content=\"webkit\" /&gt; OpenSearch现在很多网站都能实现在浏览器搜索框内直接调用网站内部搜索的功能，这是通过 OpenSearch 来做到的，而京东之前一直是没有的，这样显然是不合适，而且有一些习惯于使用地址栏搜索的用户不能满足。在这次改版中，我们加上了这一功能，使得用户可以在浏览器地址栏就能直达京东搜索。 使用Icon Font使用Icon Font可以提升设计师的发挥空间，在页面上使用一些特殊字体以提升页面的美观程度，让页面看起来更具有设计感，更加细腻，从而提升用户的浏览体验。 而且Icon Font兼容性非常好，可以让不同浏览器的用户获得一致的浏览体验，并且通过字体压缩工具，压缩后的字体文件也可以非常小，不会有太多的性能损耗。 空闲时间自动加载楼层及图片前文提到，我们使用了按需加载来提升页面性能，但这样带来的问题就是只有当用户滚动楼层到浏览器视窗内，楼层才会开始加载，这样用户滚动得稍微快一点就会出现很多loading动画。 为了减少这种情况的发生，让用户觉得楼层也加载很快，在不影响页面滚动、加载性能的前提下我们在用户操作的空闲时间自动加载剩余的楼层和图片。 将楼层的加载操作放入一个队列中，我们可以在用户停止滚动操作3s后开始自动加载这个队列中的楼层，而当用户开始滚动的时候清空这个加载队列，停止滚动3秒后又重新开始加载。通过这样处理可以合理利用用户浏览的空闲时间来加载页面，让用户感觉页面加载更快。 123456789101112131415161718192021var scrollTimer = null;var isScrolling = false;$(window).bind('scroll.loadFloor', function (e) &#123; isScrolling = true; clearTimeout(autoLoadTimer); clearTimeout(scrollTimer); autoLoadingQueue = []; resourceLoader &amp;&amp; resourceLoader.pause(); scrollTimer = setTimeout(function () &#123; isScrolling = false; if (pageConfig.idleTimeLoad) &#123; autoLoadTimer = setTimeout(autoLoad, 3000); &#125; &#125;, 200);&#125;);function autoLoad () &#123; if (!isScrolling) &#123; runFloorLoadQueue(); &#125;&#125; 页面可用性保障和监控灾备策略对于像京东首页这种大流量的网站，后端接口可能偶尔会出现错误，或者直接挂掉，特别是在双11这种可能会达到流量峰值的时候，但是不能因为接口出错的原因而使得页面显示出现错误。这就需要前端来配合给出一套合理的灾备方案。 通常，我们通过接口缓存、超时、重试来进行灾备处理。目前首页大部分接口、及所有模板请求，在请求成功后都会存入本地缓存，第二次请求，假如缓存没有过期将直接使用缓存，假如缓存过期将会重新请求，而一次正常的请求，都会经过超时或异常重试的逻辑，来保证用户能尽量访问到正常的数据，在正常接口无法获取数据之后又会有兜底接口来保障数据来源，这样的层层保障，很好地保证了页面的完整性。而且，针对所有接口，前端均有数据校验逻辑，每一个后端接口都要经过前端的数据校验，来验证接口的可用性，假如接口数据异常，前端将主动调用兜底接口来替代，这样来保证页面不至于错乱。 综上所述，首页的接口和模板正常请求流程如下 这样一套复杂的流程下，每一个接口、模板请求都是统一的，所以需要对此进行封装，以便调用。首页是通过封装改造$.ajax来实现的，使用$.ajaxPrefilter和$.ajaxTransport方法对每个异步请求进行捕获处理，将接口、模板请求的重试、超时、缓存、兜底调用等封装起来，对调用者透明，使用起来变得非常容易，而不需要关心以上灾备策略的实现。 123456789101112131415161718var ajax = require('load_async');// 本质就是$.ajax方法ajax(&#123; url: '//f.3.cn/index-floor/?argv=aggr', jsonpCallback: 'jsonpCallbakcAggr', // jsonp回调函数名 params: &#123;&#125;, // 参数 needStore: true, // 是否需要缓存 storeSign: '3aad2efsdf', //用户判断缓存是否过期的标记 timeout: 3000, //接口超时 times: 2, // 超时重试次数 backup: '//www.3.cn/bak/aggr', // 兜底接口 dataCheck: function (result) &#123; // 接口数据校验，校验接口返回数据，若为true则走正常逻辑，为false则自动调用兜底逻辑 if (result &amp;&amp; result.code === 0) &#123; return true; &#125; return false; &#125;&#125;); 数据统计驱动改进在这次首页改版项目中我们接入了Athena测速系统用于收集首页各种性能以及用户环境相关的数据，因为有了数据统计，我们才能知道用户端具体的情况信息，有了数据统计，我们才能对页面进行实时监控，有了数据统计，我们才能掌握我们做性能优化的成果，所有的分析都是要基于数据来进行，否则就是在自己在YY了。 目前我们主要收集了，用户网速、操作系统、浏览器分布、分辨率分布等各种信息，同时对于页面加载情况也有一定的监控，如页面测速打点上报、数据接口出现调用兜底接口的情况上报、楼层接口失败导致楼层隐藏的情况上报等。 通过以上数据统计，我们可以灵活地对我们的页面进行优化，同时及时发现问题，避免损失。例如我们通过统计发现用户在网速低于一定值时页面楼层隐藏数增多，这样我们就可以通过设置更长的超时时间来减少这一情况的发生，还有就是假如某时刻开始发现某接口调用兜底请求数暴增，可以判定接口出现问题而及时反馈给后端同学。 更长远的探索新版首页已经上线小一个月了，表现一直还算良好，我们做出的性能以及体验优化也得到了体现，在此基础上，我们思考了更多的可以做的工作，来提升首页的表现。 静态资源预加载首页承载着许多页面的入口，如频道页还有活动页，在双11的时候，首页会有很多直达活动的入口，如果我们能在首页预加载某些重要的活动页面的资源的话，当用户去访问这些活动页面就能更加迅速地打开浏览了。 架构升级jQuery + Seajs或许让人感到老旧且沮丧，我们考虑在首页上渐渐使用一些新的技术，例如去Seajs化，提供更优的打包方式，让页面性能进一步提升。 中间层探索目前首页虽然差不多实现了前后端分离，但是首屏这里前后端依然存在耦合，假如前端可以介入到中间层的开发，那问题就迎刃而解了，接入中间层后，我们还可以将页面部分楼层做服务端渲染，以减少前端渲染的性能损耗，可以在实现前后端分离的基础上，让页面性能更好，还是有一定意义的。","pubDate":"Mon, 26 Dec 2016 12:25:57 GMT","guid":"https://aotu.io/notes/2016/12/26/jd-index-2016-summary/","category":"项目总结"},{"title":"vim给代码行尾加分号的几种方法","link":"https://aotu.io/notes/2016/12/08/vim-4/","description":"给下面的代码每一行行尾加入分号，有几种方法呢？123var foo = 'aotu'var bar = 'is a team'var foobar = foo + bar","pubDate":"Thu, 08 Dec 2016 02:25:35 GMT","guid":"https://aotu.io/notes/2016/12/08/vim-4/","category":"Web开发"},{"title":"正则表达式实践篇","link":"https://aotu.io/notes/2016/12/07/regexp-practice/","description":"简单的练习：题目 与搜索字符串开始处的 3 个数字匹配。 与除 a、b 和 c 以外的任何字符匹配。 &#39;1234567&#39;.match(/\\d{1,3}/g)的结果。 不以“th”开头的单词匹配。 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。 匹配一个中文字符。 答案 与搜索字符串开始处的 3 个数字匹配：/^\\d{3}/。 与除 a、b 和 c 以外的任何字符匹配： /[^abc]/。 ‘1234567’.match(/\\d{1,3}/g)，根据贪婪原则，结果是 [&quot;123&quot;, &quot;456&quot;, &quot;7&quot;]。 不以“th”开头的单词匹配：/\\b(?!th)\\w+\\b/ 。 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字： /^(?=.*\\d).{4,8}$/ 。首先.{4,8} 表示与包含 4-8 个字符的字符串匹配；然后.*表示单个字符（除换行符 \\n 外）零次或多次，且后面跟着一个数字，注意(?=)只匹配一个位置。 匹配一个中文字符：/[\\u4e00-\\u9fa5]/。 当然，可能答案不唯一，不必较真啦~ 主要目的是回忆熟悉一下语法~如果还不了解正则，可以前往正则表达式理论篇 了解哇~ 真正的实践来了要想在复杂性和完整性之间取得平衡，一个重要因素是要了解将要搜索的文本。好的正则表达式： 只匹配期望的文本，排除不期望的文本； 易于控制和理解； 保证效率。 有时候处理各种极端情况会降低成本/收益的比例。所以某些情况下，不完全依赖正则表达式完成全部工作，比如某些字段用子表达式()括起来，让内存记忆下来，然后再用其他程序来验证。 不过本文还是从学习正则的角度出发，全部依赖正则表达式来写的哇~~ 匹配美元正则表达式：/^\\$[0-9]+(\\.[0-9][0-9])?$/。 分为四部分： ^\\$ 以美元符号开头。 [0-9]+ 至少包含一个数字。 (\\.[0-9][0-9])? 由一个点和两位数组成，匹配0次或1次，因为可能是整数或者是小数。 $ 最后的$表示以数字结尾的。 缺点：不能匹配$1,000 匹配24小时制的时间，比如 09:59 小时部分 方法一：分类逻辑为第一个数字(0、1、2)，可以分为三部分：上午 00点到09点（0可选）；白天10到19点；晚上20到23点。 因此有三个多选分支，得到的结果为： 10?[0-9]|1[0-9]|2[0-3] 还可以优化一下，合并前面的两个多选分支，得到： 1[01]?[0-9]|2[0-3] 方法二：分类逻辑为第二个数字，可以分为两部分：[0-3]和[4-9]。为什么这么分？看看下面这个图就知道了，[0-3]多了一行（以2为第一个数字）： 因此有两个多选分支，结果为：1[012]?[0-3]|[01]?[4-9] 分钟部分 分钟数比较简单，第一个数范围在0-5之间，第二个数在0-9之间，因此得到分钟数为: 1[0-5][0-9] 最后的结果： 小时部分用(?:)包起来，起到一个分组的作用，且不保存匹配项；冒号、分钟数拼起来；最后加上一个分界\\b表示单词的开始或结束，得到最终的结果： 123/\\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\\b/// 或者/\\b(?:[012]?[0-3]|[01]?[4-9]):[0-5][0-9]\\b/ 验证： 123var reg = /\\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\\b/;'现在是09:49点'.match(reg); // [\"09:49\"]'现在是009:490点'.match(reg); // null 其实这个结果不能说完全正确，首先你要明白这个正则用在什么地方，比如是数据验证或者复杂的字符串搜寻替换。 情景一：填写表单中的字符串必须为24小时制的时间，那么可能第一个\\b需要改成^，第二个\\b改成$。 情景二：用于复杂的字符串搜寻替换时，可能也会匹配这样子的字符串如’跑步用时19:50’,明显的，’19:50’表示19分50秒，而不是表示24小时制的时间19点50分。 匹配IP地址IP地址的规则：点号分开的四个字段，每个字段在0-255之间。 第一步： 如果一个字段是一个数或两个数，肯定是在0-255的范围内的；如果三位数，那么以0或者1开头的三位数也是合法的，即000-199。 从上面的陈述中我们就可以得到三个多选分支： 1\\d|\\d\\d|[01]\\d\\d 我们稍微合并一下这三个多选分支，得到： 1[01]?\\d\\d? 第二步： 我们再来看以2开头的三位数： 第二位数小于5的时候，第三位数范围[0-9]都可以；第二位数等于5的时候，第三位数范围[0-5] ，因此得到两个多选分支： 12[0-4]\\d|25[0-5] 第三步： 前两步合并起来，得到一个字段0-255的表示方法： 1[01]?\\d\\d?|2[0-4]\\d|25[0-5] 第四步： 四个字段合并起来，IP地址正则如下： 1/^(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/ 点号要转义一下，^和$需要加上，否则可能匹配52123.3.22.993，因为其中的123.3.22.99是符合的。(?:)起到分组的作用，且不保存匹配项。 一些测试结果： 123456var reg = /^(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/;'123.11.22.33.44'.match(reg); // null'52123.3.22.993'.match(reg); // null'123.11.22.33'.match(reg); // [\"123.11.22.33\"]'0.0.0.0'.match(reg); // [\"0.0.0.0\"] 虽然0.0.0.0是合法的，但它是非法的IP地址，使用正则的否定顺序环视功能(零宽负向先行断言)，可加上(?!0+.0+.0+.0+$) ： 1234var reg = /^(?!0+.0+.0+.0+$)(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/;'123.11.22.33'.match(reg); // [\"123.11.22.33\"]'0.0.0.0'.match(reg); // null 匹配分隔符之内的文本常见的匹配要求 匹配/*和*/之间的css注释。 匹配引文字符串””，且容许其中包含转义的引号\\”。 匹配一个HTML tag，也就是尖括号之内的文本，例如。 匹配思路的步骤 匹配起始分隔符。 匹配正文（即结束分隔符之前的所有文本）。 匹配结束分隔符。 容许引文字符串中出现转义引号大概思路描述：起始分隔符和结束分隔符都是&quot;,且正文中容许出现转义之后的引号\\&quot;。 简单情况分析： 举例：匹配类似 I &quot;start \\&quot;x3\\&quot; end&quot; U 文本的 &quot;start \\&quot;x3\\&quot; end&quot; 引文字符串，注意\\&quot;属于转义引号。 起始分隔符和结束分隔符都是&quot;。 字符不是引号，肯定是正文。即[^&quot;]表示不是引号的其他任意字符。 引号&quot;前面有反斜线\\，且被反斜线\\转义，则也属于正文。例如start\\&quot;引号的前面有一个反斜线，那么这个引号也属于正文。即(?&lt;=\\)”表示匹配一个引号，它的前面有一个\\，注意正则的反斜线也要用\\来转义一下,因为\\是特殊字符。 用非捕获分组(?:)将[^&quot;]|(?&lt;=\\\\)&quot;括起来，给个量词*，表示匹配正文0次或多次。因此可以写出正则表达式： /&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/注意：ES7才支持逆序环视(?&lt;=) 验证1：验证正则：/&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/ 12345'I \"start \\\"x3\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果： [\"\"start \"\"]'I \"start \\\\\"x3\\\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果：[\"\"start \\\"x3\\\" end\"\"] 为什么第2个才是对的呢？我们看一下返回的input属性就了解了： 验证2：验证正则：/&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/ 1234'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果与期望不符合：[\"\"start \\\"x3\\\\\" end\"\"]// 期望：[\"\"start\\\"x3\\\\\"]// 注意返回的input属性为：\"I \"start \\\"x3\\\\\" end\" U\" 引号”前面有反斜线\\，但是这个反斜线不是转义引号的，那么引号就不应该属于正文，而是属于结束分隔符。什么情况反斜线\\不转义引号呢？这个反斜线\\本身就是被转义的情况。 上面的结果按照预期结果应该返回 [&quot;&quot;start\\&quot;x3\\\\&quot;]，但是现在多了end&quot;。因此验证这个正则表达式不正确。 也就是说，正文中可出现转义的字符，因此得出正则\\\\. ，注意第一个\\表示转义第二个\\,点表示匹配除换行符 \\n 之外的任何单个字符）,例如可以匹配\\+或者\\\\。而且转义的字符已经包含了\\&quot;的情况，因此正则(?&lt;=\\\\)&quot;可以不用写了，且替换成\\\\.。 因此改正后的正则：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 你可能注意到了，我把[^”]和\\.的位置调换一下，后面的验证3会讲到为什么要这么做。 验证3：验证正则：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 和 /&quot;(?:[^&quot;]|\\\\.)*&quot;/ 123456789'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:\\\\.|[^\"])*\"/);// 结果与期望符合：[\"\"start \\\"x3\\\\\"\"]// input: \"I \"start \\\"x3\\\\\" end\" U\"// [^\"]和\\\\.的位置调换'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:[^\"]|\\\\.)*\"/);// 结果与期望不符合：[\"\"start \\\"\"]// 期望：[\"\"start\\\"x3\\\\\"]// input: \"I \"start \\\"x3\\\\\" end\" U\" [^&quot;]和\\\\.的位置调换后，结果与期望不符合。那是因为[^&quot;]匹配start \\后，遇到紧接着的&quot;不匹配，交给后面的多选分支\\\\.，也不匹配，又刚好结束分隔符是&quot;,导致匹配成功，结束匹配。 因此两个正则之间 正确的正则是 /&quot;(?:\\\\.|[^&quot;])*&quot;/ 验证4：验证：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 1234'I \"start \\\\\"x3\\\\\" end U'.match(/\"(?:\\\\.|[^\"])*\"/);// 结果与期望不符合：[\"\"start \\\"x3\\\"\"]// 注意end后面少了\",期望结果是null，不匹配// input: \"I \"start \\\"x3\\\" end U\" 上面的字符串 &quot;start\\&quot;x3\\&quot; 其实是没有结束分隔符的，但是还是匹配了。那是因为正则[^&quot;]和\\\\. 一起作用,导致匹配到了文本U末尾，后续想找结束分隔符的时候，结果却找不到，所以只能回溯文本去找结束分隔符，最后找到了 x3\\后面的引号，匹配成功，结束匹配。 回溯会导致不期望的结果，由于是卡在多选分支上出错的，因此猜测多选分支|匹配内容出现重叠。 你想想，如果符合正文的反斜线，不是以[^&quot;]方式匹配,而是以\\\\.的方式匹配，那就不会把好好的\\&quot;拆开来匹配了。 综上所述，一定要让反斜线是以\\\\.的方式匹配，字符串里的反斜杆不能以[^&quot;]方式匹配。因此将[^&quot;]改成[^\\\\&quot;]。这样子就可以确保正确识别正文特殊的\\&quot;和结束分隔符&quot;了。 注意：很多字符在[]都会失去本来的意义，但是反斜杠字符 \\ 仍为转义字符。若要匹配反斜杠字符，请使用两个反斜杠 \\\\。 改正的正则：/&quot;(?:\\\\.|[^\\\\&quot;])*&quot;/ 验证5验证：/&quot;(?:\\\\.|[^\\\\&quot;])*&quot;/ 12345678'I \"start \\\\\"x3\\\\\" end U'.match(/\"(?:\\\\.|[^\\\\\"])*\"/);// 结果与期望符合：null// input: \"I \"start \\\"x3\\\" end\" U\"'I \"start \\\\\"x3\\\\\" end\" U'.match(/\"(?:\\\\.|[^\\\\\"])*\"/);// 结果与期望符合：[\"\"start \\\"x3\\\" end\"\"]// input: \"I \"start \\\"x3\\\" end\" U\" 为了优化，我们可以把[^\\\\&quot;]放在前面，因为普通字符的匹配可能性更大。注意：优化正则提高效率最需要考虑的问题：改动是否会影响匹配。只有在排序与匹配成功无关时才不会影响准确性，才能重新安排多选分支的顺序。 优化后的正则：/&quot;(?:[^\\\\&quot;]|\\\\.)*&quot;/ HTML Tag经历了容许引文字符串中出现转义引号的例子分析，瞬间觉得这个容易了许多。 描述与要求：匹配类似&lt;input name=123 value=&quot;&gt;&quot; &gt;的HTML标签，起始分隔符是&lt;，结束分隔符是&gt;，且HTML 标签属性值中可以出现&gt;。 起始分隔符和结束分隔符都是明确的，我们来分类一下正文。 双引号引用文本 单引号引用文本 除了&gt;和引号之外的任意字符 可能你会当心单双引号引用文本，会像“容许引文字符串中出现转义引号”那么复杂。幸好是HTML Tag的属性值中不允许出现转义引号，因为平常的转义符号\\变成了普通字符。 根据三种情况，分别写出三个正则： &quot;[^&quot;]*&quot; &#39;[^&#39;]*&#39; [^&#39;&quot;&gt;] 好了，用多选分支连起来&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;]，再用非捕获分组(?:)将多选分支括起来，如(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])，用*表示匹配任意次，最后前后加上开始结束分隔符，搞定： /&lt;(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;/ 验证： 12'&lt;input name=123 value=\"&gt;\" &gt;'.match(/&lt;(?:\"[^\"]*\"|'[^']*'|[^'\"&gt;])*&gt;/)// 结果： [\"&lt;input name=123 value=\"&gt;\" &gt;\"] 体会：看到没有，几乎每个正则都包含多选分支，只要你懂得将数据分类，离成功就不远了。哈哈哈哈哈。 参考《精通正则表达式》http://imweb.io/topic/56e804ef1a5f05dc50643106","pubDate":"Wed, 07 Dec 2016 02:34:01 GMT","guid":"https://aotu.io/notes/2016/12/07/regexp-practice/","category":"Web开发"},{"title":"源码赏析 - 1K的Firewatch游戏","link":"https://aotu.io/notes/2016/12/04/firewatcher-appreciation/","description":"前言讲真，做前端越久，我们就越容易被思维所束缚。比如，应该没几个人会相信用1K代码能够写出一个游戏，而且还是3d的游戏。 在看这段代码之前我们不得不提到一个一年一度的比赛：js1k。每年，主办方会提出一个比赛主题，参赛者们必须围绕这个主题，用1024个字节以内的JS代码做一个参赛作品。比赛的要求有以下几个： Create a fancy pancy JavaScript demo (用JS做出一个华丽的demo) Submissions may be up to 1024 bytes (最多1024字节) Externals are strictly forbidden (禁止引用外部资源) Must work current generation browsers (必须能在现代浏览器中运行) Minification and hacks allowed (允许代码压缩或者hack) 另外，作为基础，demo运行的环境中内置了一部分变量供调用： window.a 是一个canvas元素 window.b 是document.body window.c 是a元素对应的2D/3D上下文 window.d 是document对象 是不是还挺贴心？只需要用一个字母就可以调用原本一长串代码才能拿到的对象喔。 除了这些，比赛还有一些小规则，可以查看比赛的 规则页 ，里面有详细描述，这里就不再多说。 今年比赛的主题是 Let’s get eleMental!，我们今天要看的 Firewatch 就是其中第三位的作品（第一名作品是 Romanesco 2.0 3D分形展示，有强烈的不明觉厉感，建议前往围观；第二名 Voxeling 是一个3D像素Demo）。 Demo介绍游戏通过键盘上下左右+空格键操作。在开始游戏后，面前会有一颗烟花炸开。紧接着烟花下的树开始着火。玩家的任务就是按下空格，用水枪将火扑灭。在一定时间后，树上的火还会点燃周围的树。如果不慎走神，很有可能就救不回这片森林了喔。 源码解析粗略地讲，这份源码总共就分为两个部分： 创建对象 绑定用户交互，进行事件循环 创建对象下面是创建对象部分的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// add treesfor (entities = [playerA = 256]; s = playerX = playerZ = playerA--;) for ( // create trunk entities.push(&#123; c: [i = 12, 60, 30], x: X = Math.sqrt(playerA) * 12 * Math.cos(playerA) + Math.random() * 12, h: 1, y: Y = Math.random() * 3 - 1, z: Z = Math.sqrt(playerA) * 12 * Math.sin(playerA) + Math.random() * 12, s: 2, S: Y * 2 + 16 &#125;); i--; // create leaf entities.push(&#123; c: [150, 60, i * 2], x: X + f * Math.cos(e = Math.random() * 7), z: Z + f * Math.sin(e), h: 860, y: Y - i / 2 + 10, s: 8 &#125;) ) // create fallen fruit f = Math.random() * 7, i % 2 || entities.push(&#123; c: [50, 60, i * 2], x: X + f * Math.cos(e = Math.random() * 7), z: Z + f * Math.sin(e), h: 860, y: -8, s: 1 &#125;);// burn a leaf (doubles as object for active keys)entities[30].p = burn = function (e, f) &#123; // update fire e.h--; e.c = [Math.random() * 60, 100, 0], e.s = Math.random() * 5 + 6, // create smoke / fireworks s % 16 || entities.push(&#123; c: [0, 0, e.w ? -30 : 10], x: e.x + Math.random() * 6, y: e.y, z: e.z, h: 90, v: 60, p: s ? function (e, f) &#123; e.h--; e.y += .5 &#125; : function (e, f) &#123; e.h--; e.c = [Math.random() * 60, 100, 0], e.h &lt; 12 ? e.s += 3 : e.y += 3 &#125;, s: 4 &#125;); // spread fire entities.some(function (f) &#123; return(s % 300 || f.s == 8 &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; 40 &amp;&amp; Math.random() * 50 &lt; 1 &amp;&amp; (f.p = burn)) &#125;); e.w = 0&#125;; 为了减少代码占用的空间，作者大量使用了单字母的变量名与属性名，比如entities.c，entities.x等等，代码可读性非常差。 浏览一遍，我们是根本看不出上面这些变量是什么含义了。 但是，我们能够确定的是，这段代码初始化了playerA，playerX，playerZ变量，然后把所有的对象设定好属性后都存入了entities数组中，包括树干，树底下的水果，还有树干等等。没办法，只能先跳过这部分了。 用户交互这是代码中主管用户交互的代码： 123onkeydown = onkeyup = function (e, f) &#123; burn[e.keyCode - 32] = e.type[5]&#125;; 蛤？就这么短？ … 真是这么短。 上面这段代码，看着更像是定义了onkeydown跟onkeyup俩函数，后面理应还有类似于addEventListener之类的语句将这个函数绑定给某个元素某个事件的代码。因为身为前端，我们早已习惯绑定事件的那几种套路： 1234DomEl.addEventListener(eventname, callback); // webkitDomEl.attachEvent(eventname, callback); // IE$.bind(eventname, callback); // jQ// ... 可是任凭老司机怎么 Ctrl+f 搜索代码，也并没有找到所谓的绑定事件的语句。 事实上，作者在定义这两个函数的时候，并没有使用var关键字。意味着，这后面定义的变量，是直接挂在window下的。那么凭空定义的这两个函数，就分别会变成 window.onkeydown 和 window.onkeyup 。没错，这就是我们极度不推崇的绑定回调的方式了。 回调函数的内容，是在用户按下按键的时候将burn中下标为 keyCode - 32 的属性设定为 keydown 或者 keyup 的第六个字母，也就是 w 或者 undefined 。这个做法十分精妙，下面举例说明。 假设我们按下了空格键（keyCode=32），执行 onkeydown 函数，burn[0] = &#39;w&#39;；而放手的时候，则执行 onkeyup 函数， burn[0] = undefined 。这样一来，在事件循环里面只需要判断burn[0]是true还是false，就可以知道空格键按下了没有。同理，burn[5]，burn[6]，burn[7]，burn[8]分别代表了左，上，右，下键的状态。 可是，印象中burn是个函数呀，entities[30].p = burn = function (e, f) {...}，怎么就用来表示按键状态了呢？目的只能有一个，省下一个声明变量的语句。 为了省下多几个字符，程序员真是什么事都做得出来啊… 事件循环终于到了事件循环部分了。这部分代码占了源码大概一半的篇幅。折叠后，代码结构大概是这样的： 结构大概清晰了：首先是玩家的移动，接着是水枪的处理，紧接着是背景天空森林地板的渲染。 每个事件循环一开始，先是移动玩家。1234// move playerplayerA += (!!burn[7] - !!burn[5]) / 20,playerX += (e = !!burn[6] - !!burn[8]) * Math.sin(playerA),playerZ += e * Math.cos(playerA), 理解了用户交互部分的内容，这里就很好理解了。burn[5]与burn[7]分管左右两键，那么playerA很明显就是用户的朝向。而burn[6]与burn[8]分管前后，在经过换算后，我们很快也就能知道playerX与playerZ分别是玩家在x-z平面上的坐标。别忘了这游戏可是3D的，所以并不用x-y坐标系。 接下来是水枪的代码： 1234567891011121314151617181920// discharge waterburn[0] &amp;&amp; entities.push(&#123; c: [200, 60, -5 * Math.sin(s)], x: playerX + 12 * Math.cos(playerA), z: playerZ - 12 * Math.sin(playerA), e: playerA - .5, s: 2, h: 20, p: function (e, f) &#123; e.h--; e.x += 2 * Math.sin(e.e), e.z += 2 * Math.cos(e.e), e.y = 5 - (e.h / 2 - 5) * (e.h / 2 - 5) / 2, entities.some(function (f) &#123; f.p == burn &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; e.s / 2 + f.s / 2 &amp;&amp; ( f.h -= f.w = 9 ) &#125;); &#125;&#125;); 只要空格被按下，就会有新的对象被插入entities数组中。不过既然是水枪的代码，我们很容易可以想到，这里插进去的对象正是水流。 水流浇到火上是可以灭火的，所以下面这段带有一堆abs的代码，十有八九是用来判断水流跟火焰的位置关系的。 12345entities.some(function (f) &#123; f.p == burn &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; e.s / 2 + f.s / 2 &amp;&amp; ( f.h -= f.w = 9 )&#125;); 后面可以证明我们的猜测并没有错。另外，这段代码最后的&amp;&amp;符号后面的代码，就是灭火的处理函数了。 遍历数组，我们一般是用forEach，而作者在这个例子中全都是用some来做的。我猜作者并没有别的用意，纯粹是因为长度的原因。所以我觉得这里使用map应该更好。 接下来是一些零散的处理。 1234567// prepare canvasc.translate(90, (a.height += 0) / 2 - 120 | 0);// update entitiesentities.some(function (f) &#123; f.p &amp;&amp; f.p(f)&#125;); 首先是平移了画布，其次是遍历对象数组，执行对象的p函数。这样一来就很清晰了。对象的属性p，就是在每个事件循环中处理对象的函数。 1234// draw skyfor (i = 30; i--;) c.fillStyle = 'hsla(' + [160, 60 + '%', 50 + i + '%', 1], c.fillRect(0, i * 4, 320, 4); 接下来，作者巧妙地用循环 + hsla渲染了一个带渐变色的天空。 1234// remove entities no longer neededentities = entities.filter(function (e, f) &#123; return(e.h &gt; 0)&#125;); 这段代码过滤掉了对象数组中h属性不大于0的对象。 回想一下，我们前面看到的每种对象的p函数，都带着h–，而p函数在每个事件循环都会执行。那么这个h属性表示的就是对象的寿命了。这个事件循环的间隔是33ms，也就是30h相当于1秒。 1234567891011121314151617// draw background forestfor (i = 30; i--;) c.fillStyle = 'hsla(' + [160, 60 + '%', 10 + i + '%', 1], c.fillRect(0, 220 - i * 4, 320, 4);// sort entities by distance from the screenentities.some(function (f) &#123; f.Z = (f.x - playerX) * Math.sin(playerA) + (f.z - playerZ) * Math.cos(playerA)&#125;);entities.sort(function (e, f) &#123; return(f.Z - e.Z)&#125;);// draw groundfor (i = 30; i--;) c.fillStyle = 'hsla(' + [10 + 60, 60 + '%', 50 + i + '%', 1], c.fillRect(0, 236 - i * 4, 320, 4); 接下来的这部分，前面的画背景与后面的画地板还是跟前面一样的套路，分别使用循环来绘制带渐变色的森林与地板。可是中间这段是什么鬼？ 根据注释说明，这个部分是将Z属性设置为对象到屏幕的距离，随后做了一次从近到远排序。 至于对象到屏幕的距离如何计算，这里直接画图说明，就不再赘述。 12345678910111213// draw entitiesentities.some(function (f) &#123; !f.v &amp;&amp; f.Z &gt; 160 || f.Z &lt; 8 || Math.abs(e = (f.x - playerX) * Math.cos(playerA) * 160 / f.Z - (f.z - playerZ) * Math.sin(playerA) * 160 / f.Z) &lt; 160 &amp;&amp; ( c.fillStyle = 'hsla(' + [f.c[0], f.c[1] + '%', f.Z / 6 - f.c[2] + 46 + '%', f.S ? 1 : .8], c.fillRect( 160 + e - f.s * 160 / f.Z / 2, 120 - f.y * 160 / f.Z - (f.S || f.s) * 160 / f.Z / 2, f.s * 160 / f.Z, (f.S || f.s) * 160 / f.Z ) )&#125;); 接下来的这段代码就是这个游戏的灵魂所在了。 这是一个遍历entities数组的操作。以 || 符号分割，这个操作可以分为三个部分： !f.v &amp;&amp; f.Z &gt; 160 f.Z &lt; 8 Math.abs(...) &lt; 160 &amp;&amp; (...) 语句1跟2只要有一个成立，语句3就不会被执行。语句1跟2也很好理解，主要是判断对象跟屏幕之间的距离是不是处在(8, 160)的区间内，如果不是就直接跳过该对象。 这里有一个例外情况，在距离大于160的情况下，如果对象带有v属性则还是可以继续后面的判断的。纵观整个代码，带有v属性的只有前面提到的烟雾以及烟花。这就说明烟雾与烟花就算是在160距离开外，依然是可以看到的，事实上也的确如此。 语句3被 &amp;&amp; 符号分割为了两部分： Math.abs(e = (f.x - playerX) * Math.cos(playerA) * 160 / f.Z - (f.z - playerZ) * Math.sin(playerA) * 160 / f.Z) &lt; 160 (c.fillStyle=&#39;...&#39;,c.fillRect(...)) 语句1中的比较，转换为代数式，经过简单的代数变换后，可以变为： dx*cos(α) - dz*sin(α) &lt; f.Z 结合刚刚的图，这个语句意义就是指，线段a需要小于f.Z。而从图上我们可以知道，线段a就是对象投影在屏幕上后与玩家的距离。这样一来，视角90°以外的对象就不会被渲染了。 语句2就是渲染对象的语句了。看到这里的fillStyle函数我们才明白，前面所定义的f.c属性，其实就是定义了对象颜色的hsl值。另外，从fillRect函数的传参情况来看，也很容易看出f.y指的就是对象的y坐标，f.s表示对象的宽高，而f.S则是在绘制树干的时候作为对象的高度来使用。 再回首现在我们对这段代码有大概的理解了，是时候回头看一看了。 首先是创建对象的部分，此处开了两重循环，种下了256课树，每棵树分别有一根树干，12个对象组成的叶子，另外地上有6个果实。 接下来，第30棵树被恶意纵了火（将f.p设置为burn函数），第一棵着火的树还会发出一个烟花作为信号。而由于每一帧最后都有s--语句，这个s被作为一个计数器，让着火的树每16帧发出一个烟圈。 过后，就是熟悉的与用户交互的环节了。这部分已经十分清晰，就不再赘述。 写在最后这段代码虽然短，却是麻雀虽小五脏俱全。实现了游戏的基本功能不说，有一些小细节也是让我大吃一惊。比如树着火时冒出的烟，在普通情况下是深灰色的，而在被水枪浇到的时候，会变成浅灰色；又比如寿命的设定，使树叶在着火之后一段时间会被烧完。 在编程思想上，作者也是很有见地。使用entities数组存储所有对象的信息，给每种对象一个变换函数，这本身就有粒子的思想在其中。此外，setInterval的使用，则是再正常不过的事件循环机制的实现。 编程手法就不用多说了。比如各种利用some函数代替forEach来省字数，又或者是利用burn[e.keyCode - 32] = e.type[5]来判断按键的状态……作者是老司机，这一点是没跑了。 这段代码构思巧妙，思路行云流水…类似的溢美之词说再多也没用。更关键的是，我们干前端这一行的，绝对不只是jQ，选择器，或者node小工具。偶尔看一看别人的代码，还是能够学到很多意想不到的知识的。 参考资料 js1k官网 http://js1k.com js1k规则页 http://js1k.com/2016-elemental/rules Romanesco 2.0 http://js1k.com/2016-elemental/demo/2552 Voxeling http://js1k.com/2016-elemental/demo/2497 Firewatch http://js1k.com/2016-elemental/demo/2512 Firewatch 源码 http://js1k.com/2016-elemental/details/2512","pubDate":"Sun, 04 Dec 2016 15:33:00 GMT","guid":"https://aotu.io/notes/2016/12/04/firewatcher-appreciation/","category":"js1k 游戏 3D"},{"title":"项目心得 -- 京东云改版","link":"https://aotu.io/notes/2016/12/02/jcloud/","description":"2016年即将过去，回顾总结项目的时候，发现日常工作中一些值得我们思考的地方，这次选了印象比较深刻的京东云项目，希望本文能对读者有所帮助，文多图少，一目百行的客官请轻虐。 项目变数由于项目的紧迫性，项目进度基本处于多线并行追赶的状态，产品、视觉、前端三个线边输出边交接，产品和视觉会把重要的框架性的页面先输出给到前端，这样一来，前端得到的交互文档、视觉稿基本是阶段性的，并没有完整的项目逻辑和项目页面可以参考来评估项目的构建方案，项目的公用模块、公用组件、组件管理方式等全局性的内容难以确定，类似这些项目中各种不能确定的信息，我称之为『变数』。『变数』会给构建页面过程带来很多不可预测的问题，这些问题可能会令一部分工作推倒或翻工。 主动获取项目信息面对这种时间线短、各线并行、存在『变数』的项目，主动获取项目信息尤其重要，个人觉得比较重要的有以下几个：项目整体信息结构、整体的时间线规划、视觉稿的具体输出日期、视觉交接 Deadline、前端开发的周期、前端交接 Deadline、项目各线对接负责人。 这次项目属于改版类，从旧版大概了解到站点频道划分、频道之间逻辑关系、业务模块的引用情况等信息，这次改版产品的逻辑变化不大，主要是视觉的优化。虽然前期视觉给到我们的视觉稿只有站点首页，频道的首页和频道的内页都还在并行进行中，但从旧版站点逻辑和产品交互侧得到的信息以及已出的视觉稿可以确定站点哪些部分可以作为公用组件去制作，也可以大致确定项目的资源目录分布。 对于旧站点常见的组件而在已出视觉稿未体现到的，如侧导航弹浮层，找到产品和交互进一步了解后，得知会在频道首页和内页会用到，亦可以确认作为公用组件制作，并可以提前为这些组件制作评估工作量并选择最佳的实现方案。 整体的时间线规划、视觉稿的具体输出日期、视觉交接 Deadline、前端开发的周期以及前端交接 Deadline，这些信息都是项目时间维度上的信息，这类信息的确认，可以让我们更准确评估工作量（在时间线内是否可以完成所有工作），从而在项目紧急性方面做好更合理的人力投入。 潜在『变数』我们接到新项目，一般都会考虑以上的因素，主动去获取项目的信息，这些信息都是显而易见的，但有些信息略显隐蔽。 拿到设计稿的时候，发现视觉设计师只提供了一份 1280 分辨率的宽屏版，国内分辨率使用占比名列前 5 的 1024 分辨率并没有兼容，带着疑问找到视觉确认，得知首页会有 1280 分辨率和 1024 分辨率两个版本，适配 1024 分辨率版本会迟一点给到。 对于这种看似不是问题的问题而前期又可以确认的问题，我是一定要去确认的！这种问题在前期看上去并不会成为项目推进的阻力，但是说不定会在项目后期爆发，对项目造成吨暴击伤害。 记得刚入行的时候就亲身经历过联调阶段调整分辨率兼容问题，产品说『我的笔记本电脑首页出现横向滚动条了』，然后去排查了一下，发现产品用了 1024 分辨率，而视觉给到前端的视觉稿只兼容到 1280 分辨率，当时缺少实际项目经验，就默默按照 1280 去做了。当产品找到视觉，视觉回答『立项的时候文档没有写到分辨率兼容情况呀，所以当时只做了宽屏1280了』，最后产品『还是兼容一下吧，做一个窄版适配吧』，再然后视觉和前端就只能『……』。 这种问题两条线人员很容易懵B『O嘴』，而且最终还是需要重新调整适配 1024 分辨率，视觉和前端两条线都需要额外的工时，而这些工时并不在前期规划内，所以最有可能会令到视觉或前端或两者都加班，如果加班在可控的时间内完成的话还算是亡羊补牢，但如果加班后还是影响到项目进展造成项目 delay 的话，那就不是影响视觉和前端两条工作线工作效率这么简单了，这是一种潜在的『变数』，应该如何避免这种『变数』的出现，非常值得我们去思考。 如果前端可以从立项就开始参与和产品、交互、视觉、开发各线大前期沟通的话，每个岗位的同事都可以就各自的专业去衡量评估项目，是不是能更早地去发现一些潜在的『变数』呢？而去执行实现的话是否需要在流程上做出改动？如果因为团队的合作模式不能实现，作为前端，我们是不是应该更主动去找到各线的同事进行沟通？ 当然，这仅仅是针对此情况而去考虑的东西，其实我想提出的是，面对『项目变数』我们需要做的就是尽可能及时掌握更多关于项目的任何信息去深入了解项目，对项目未来发展作出预见性的判断从而掌握主动权，而不是静静地等待进入前端流程。项目可见度越高，准备越充分，项目主动性越强，只有 100% 的项目信息确认，才能 Kill the 『潜变数』Tens of Thousands Times。 方案推动首页的设计稿包含了很多单色图标，图标复用性很强，同一个图标出现在不同的模块，而且大小又不一样，又需要多态并且兼容 Retina 高清屏。 站在前端角度考虑，PC平台的解决方案，第一时间肯定会想到 iconfont 图标。iconfont 图标已不是什么新鲜的技术，不少同事都在不少项目中都有应用到，可是大家在遇到同一问题使用相同技术的时候，处理方法亦有不同。有的同事可能会自己制作 iconfont 图标；有的同事可能会让设计师提供图标 SVG 文件，利用线上的工具自动生成 iconfont 图标；有的同事可能会把 iconfont 的生成工具介绍给视觉设计师，让视觉设计师生成 iconfont 图标。 站在视觉角度考虑，当然想图标在所以设备都可以高清呈现。不同的设计师经验不一样，有些可能会提供 SVG 文件，有些可能会提供一套1X，2X图，有些甚至会把 3X 图也一起给到前端 当项目同时由多人维护的时候，就可能会出现同一个项目同样的的技术方案出现不一样的协作方式，一旦人员交叉交接的时候，就有意思了。从协作效率上来看是存在一定问题的，因此很有必要让前端和视觉设计师统一一套解决 iconfont 图标的方案。 如何实行？ 个人觉得，最重要的是让大家对问题达成共识，也就是：解决这个问题于工作有何收益？ 首先需要站在视觉方角度让他们知道问题痛点，再提出解决方案并希望得到他们的协作，下面我以对话的形式将当时我和视觉沟通的对话内容简单叙述一下（前端：FE，视觉：VD）： FE：啊宏，这些单色图标数量挺多的呀，复用率又高，很多还有双态，同一个图标还有不一样的尺寸，全部做成图片的话数量很多哇，即使全部合并成 sprite 图，图片的 K 数也会很大呢。最要命的是图标后续不知道还会有多少种色态会扩展，首页还要求适配高清屏呢，这工作量不是一般的小呀。 VD：确实啊，高清屏适配每一个图标我都要给一个 2X 图你，10个图标我就得给你 20 个，如果有双态的话，就得给你40个,这次首页纯色图标就有50个。。。 FE：嗯，会出人命的，主要这些图标都是纯色图标，都做成图片不值得，用 iconfont 图标可以解决，全矢量，还可以用样式控制尺寸大小和颜色，高清屏、尺寸、配色都不是问题呀，省力省时间呢！ VD：666，那这个 iconfont 图标要怎么个搞法啊？我需要做些什么呢？ FE：只需要把图标做成 SVG 文件提供给我就 OK 了呀，网上有 SVG 转 iconfont 图标的服务哈 VD：没问题呀，如果能解决刚才说的问题 FE：是啊是啊！主要是这样处理的话可以节省大家的时间，效率成倍提高的啊，不过生成 iconfont 图标后有些图标会在 windows 显示出问题，有问题的图标需要你用 Ai 再处理一下哟，没问题吧？ VD：没问题啊，总比切一堆图好吧，哈哈~~ FE：好的，那么我们约定好，以后这一类纯色图标我们都统一用 iconfont 图标处理，由视觉这边提供图标的 SVG 文件，然后前端负责生成 iconfont 图标，我会在组内推一下这个处理 iconfont 的流程，麻烦你在视觉组内也推一下这个方法哈，都统一这么处理，看OK么？ VD：好的没问题~~ 6666 ~~~ FE：6666~~ 项目最后一共投入了5个人力完成后期的构建，成功统一使用了这个 iconfont 图片处理流程，避免了一大波 icon 的蹂躏： 痛点定位和效率收益是这次协作成功推动的关键点，个人觉得要成功推动一个方案实施，『痛点』及『收益点』必定是核心点。以上仅仅是一个简单的方案推动例子，真正操作起来也不会太困难，但关键是我们需要从每次的工作收益中沉淀点『好西』出来就很好了。 好了，以上就是我在京东云改版项目中对工作流程以及上下线协作中感受比较深的一些思考和总结。其实问题都很常见，也有很多更好的解决方案，但是要将这些问题和解决方案存在的价值转化出来，还是需要我们做完每一次的项目后认真去总结沉淀，最后，做好业务无非几个字，想得周全，助得快乐，踩得深入，跳得出来。","pubDate":"Fri, 02 Dec 2016 08:26:14 GMT","guid":"https://aotu.io/notes/2016/12/02/jcloud/","category":"项目总结"},{"title":"css3 animation 属性众妙","link":"https://aotu.io/notes/2016/11/28/css3-animation-properties/","description":"本文不会详细介绍每个 css3 animation 属性（需要了解的同学可先移步 MDN），而是结合实际的开发经验，介绍 css3 animation 属性的一些使用场景及技巧。 1. animation-delayMDN 中的介绍： animation-delay CSS 属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。 该属性值默认为 0s，可为正值，也可为负值。 动画时间轴由于 css3 动画没有时间轴，animation-delay 最常见的是用于将动画与其他动画的执行时机错开，将动画落到不同的时间点，形成动画时间轴。12345678910.ani--first &#123; animation-name: aniFirst; animation-duration: 2s; animation-delay: 0s;&#125;.ani--second &#123; animation-name: aniSecond; animation-duration: 1s; animation-delay: 2s; /* aniSecond 延迟 2s 执行*/&#125; 形成的时间轴如下图所示： 轮播css3 animation 亦可实现一些 js 的效果，例如利用 animation-delay 可以实现一个简单的轮播。以下是一个三屏轮播的例子。123456789101112.slider__item &#123; animation: ani 6s infinite linear both; @for $i from 1 to 4 &#123; &amp;:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-1+$i)*2s; &#125; &#125;&#125;@keyframes ani &#123; 0%, 33.33% &#123;opacity: 1; visibility: visible;&#125; 33.34%, 100% &#123;opacity: 0; visibility: hidden;&#125;&#125; See the Pen KNvRxZ by Yetty (@Yetty) on CodePen. 序列动画多个元素使用相同的动画效果时，将动画执行时机依次错开，可形成整齐有序的序列动画效果。12345@for $i from 1 to 6 &#123; .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-1+$i)*0.1s; /*计算每个元素的 animation-delay */ &#125;&#125; See the Pen listAni by Yetty (@Yetty) on CodePen. 以笔者开发的京东2017海外招聘项目为例，第二屏的菜单和第三屏的时间轴的进退场动画都运用了序列动画。下图展示第三屏时间轴的进场效果，有兴趣的同学亦可扫码观看完整案例。 无限循环的序列动画animation-delay 可为负值。负值会让动画从它的动画序列中某位置立即开始。 巧用这个负值，可以解决实际开发中的一些问题。 如若上述的序列动画要进行无限循环，单纯将 animation-iteration-count 设置为 infinite，动画开始时会有延迟。此时，将 animation-delay 设置为负值，提前动画开始执行的时机，当用户看到动画时，动画便已经处于进行中的状态。12345@for $i from 1 to 6 &#123; .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: -$i*0.1s; /* animation-delay 为负值*/ &#125;&#125; See the Pen listAniInfinite by Yetty (@Yetty) on CodePen. 调试动画将 animation-play-state 设置为 paused，animation-delay 设置成不同的负值，可以查看动画在不同帧时的状态，便于进行动画调试。 12345678910111213141516171819.list__item &#123; animation: listAni 0.5s linear both alternate infinite; animation-play-state: paused;&#125;@for $i from 1 to 6 &#123; .list--first .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: -$i*0.1s; &#125;&#125;@for $i from 1 to 6 &#123; .list--second .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-2-$i)*0.1s; &#125;&#125;@for $i from 1 to 6 &#123; .list--third .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-4-$i)*0.1s; &#125;&#125; See the Pen listAniPaused by Yetty (@Yetty) on CodePen. 2. animation-fill-modeMDN 中的介绍： animation-fill-mode 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。 animation-fill-mode 应该算是 animation 属性里比较难上手的一个，但它的作用却很大。 保持结束状态“动画结束后，突然跳回第一帧！” 很多刚接触 css3 动画的同学，都是在这个场景下，接触了 animation-fill-mode 属性。将 animation-fill-mode 设置为 forwards，动画执行结束后保持最后一帧的样式。1234.ani-area__item--forwards &#123; animation: ani 1s ease; animation-fill-mode: forwards;&#125; See the Pen MbmvQL by Yetty (@Yetty) on CodePen. 开始前状态开发动画时，我们都是先根据视觉稿做好构建，再来给元素加动画的。如上文所述，可通过 animation-delay 来延迟的动画的执行。而在执行前，元素往往需要先隐藏（translate 定位到视窗外 / opacity 设置为 0 / scale 设置为 0 等）。若将隐藏元素的样式直接应用到元素上，一来不利于构建，二来对于不支持动画的浏览器来说，只会呈现一片空白。此时，animation-fill-mode 的 backwards 属性值便派上用场。 对于 backwards 的解释，笔者见过不少文章的说法都有不妥之处，认为 backwards 与 forwards 相反，表示动画执行结束后保持第一帧的样式。实则不然，我们看下 w3c 的解释： backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 换句话说，backwards 作用的是 animation-delay 的时间段，应用第一个关键帧的样式。1234.ani-area__item--backwards &#123; animation: ani 1s 1s ease; animation-fill-mode: backwards;&#125; See the Pen YpVxpw by Yetty (@Yetty) on CodePen. 当然，动画的第一帧和最后一帧的计算还受 animation-direction 和 animation-iteration-count 的影响，MDN 中有详细解释： forwards animation-direction animation-iteration-count last keyframe encountered normal even or odd 100% or to reverse even or odd 0% or from alternate even 0% or from alternate odd 100% or to alternate-reverse even 100% or to alternate-reverse odd 0% or from backwards animation-direction first relevant keyframe normal or alternate 0% or from reverse or alternate-reverse 100% or to 3. animation-direction既然上表中涉及了 animation-direction 属性，那我们就顺着来研究一下它。MDN 中的介绍： animation-direction CSS 属性指示动画是否反向播放。 进/退场动画复用动画元素有进场动画，往往也会需要退场动画。比较常见的做法，退场时使用与进场动画反向的动画。animation-direction 的 reverse 属性值可简单实现反向动画。 先看MDN 中的介绍： reverse：反向运行动画，每周期结束动画由尾到头运行。 1234567891011121314.on &#123; .ani--translate &#123; animation: aniTranslate 1s ease forwards; &#125;&#125;.off &#123; .ani--translate &#123; animation: aniTranslate 1s ease forwards reverse; &#125;&#125;@keyframes aniTranslate &#123; 0% &#123; transform: translateY(300px) &#125; 100% &#123; transform: translateY(0) &#125;&#125; 123$wrap.removeClass('on');$wrap.innerWidth($wrap.innerWidth); /* 使用 reflow 重新触发一下 animation */$wrap.addClass('off'); See the Pen YpQqKZ by Yetty (@Yetty) on CodePen. 当然，上述例子为了演示方便，只是简单做了只有两帧的动画，这种效果用 transition 同样可以实现。 4. animation-play-stateMDN 中的介绍： animation-play-state CSS 属性定义一个动画是否运行或者暂停。 翻页动画控制在做翻页 h5 时，需要对动画的播放进行控制。只有当用户进入当前屏时，动画才开始播放。通常我们会给当前屏加上一个 acitve 类，用来给元素添加动画：123.active .ele &#123; animation: ani 1s ease;&#125; 或者如上文“进/退场动画复用”中的例子，分别用 on 和 off 控制进/退场动画。这都是常见的思路。如果是不需要重复触发的动画，用 animation-play-state 同样可以实现动画的控制。动画属性直接添加到元素上， animation-play-state 默认设置为 paused，当进入当前屏时，将 animation-play-state 设置为 running 即可。1234567.ani &#123; animation: ani1 1s ease; animation-play-state: paused; /* animation-play-state 默认设置为 paused */&#125;.active .ani &#123; animation-play-state: running; /* 进入当前屏，animation-play-state 设置为 running */&#125; See the Pen vymWwE by Yetty (@Yetty) on CodePen. 轮播的交互在前文介绍 animation-delay 时，提到了一个轮播的例子，当用户 hover 时，轮播动画应该暂停，用 animation-play-state 属性便可轻松实现交互：123.slider:hover .slider__item&#123; animation-play-state: paused;&#125; 5. animation-timing-functionMDN 中的介绍： CSS animation-timing-function 属性定义 CSS 动画在每一动画周期中执行的节奏。 关于 animation-timing-function，有一个特别需要注意的点，MDN 中有强调： 对于关键帧动画来说，timing function 作用于一个关键帧周期而非整个动画周期，即从关键帧开始开始，到关键帧结束结束。 也就是说，animation-timing-function 是作用于 @keyframes 中设置的两个关键帧之间的，这一点在该属性值为 steps() 时可明显感知。 逐帧动画animation-timing-function 最让人感到惊（beng）艳（kui）的莫过于 steps() 属性值。利用 steps()，可以轻松实现逐帧动画（又称“精灵动画”），从而告别不可控的 gif 时代。关于逐帧动画，笔者之前在凹凸实验室平台已经发布过相关文章介绍，此处不再赘述，有兴趣的同学可前往围观：《CSS3逐帧动画》。 参考文章： Debugging CSS Keyframe Animations - SARAH DRASNER 多屏复杂动画CSS技巧三则 - zhangxinxu 打造H5动感影集的爱恨情仇(动画性能篇) －TQ","pubDate":"Mon, 28 Nov 2016 02:00:00 GMT","guid":"https://aotu.io/notes/2016/11/28/css3-animation-properties/","category":"Web开发"},{"title":"三看 SVG Web 动效","link":"https://aotu.io/notes/2016/11/22/SVG_Web_Animation/","description":"CSS3 动效玩腻了吗？没关系的，我们还有 SVG。","pubDate":"Tue, 22 Nov 2016 09:33:00 GMT","guid":"https://aotu.io/notes/2016/11/22/SVG_Web_Animation/","category":"Web开发"},{"title":"FIGlet初识","link":"https://aotu.io/notes/2016/11/22/figlet/","description":"FIGlet这个词诂计对于很多前端工程师来说可能比较陌生，但在计算机领域中常常见到。早在十几年前就已经开始有许多利用文字与线条组成的图形，当时甚至用 ASCII 来表示颜色，然而到了今天也被广范使用。","pubDate":"Tue, 22 Nov 2016 09:33:00 GMT","guid":"https://aotu.io/notes/2016/11/22/figlet/","category":"Web开发"},{"title":"「塔罗牌」 - 轻氧 V1.4 尝鲜体验邀请","link":"https://aotu.io/notes/2016/11/21/liteo2-app-tarots/","description":"今天要介绍的是轻氧1.4版本，Code Name「塔罗牌」，这是一个玩儿的版本。 如果你还不知道轻氧是什么鬼，那末可以先移步这里：轻氧 - 2016年末最新款互联网专业资讯 APP，或者直接关注「凹凸实验室」的公众号以获取更多轻氧APP的最新讯息。 在轻氧上一个版本（响尾蛇）推出的时候，我们在实验室的公众号做了一次小范围的推广，总用户数虽然谈不上惊喜，但也超出了一开始的期望，且每日俱增。 朋友们所给的评论和意见，不管褒贬我们都有记录，而其中呼声最高的安卓版本，我们已优先列入开发计划，技术选型上我们决定尝试使用阿里的weex，支持国货，人人有责。 塔罗牌（Tarots)「看看资讯，玩玩牌」，我们其实就是想给「轻氧」加一个神秘好玩的功能，类似远古时代的「占卜」，通过用户主动给予它的一些交互引出一些未知的功能，这个版本叫「塔罗牌」，打开APP，相信你们就知道怎么玩。 玩法实在不会玩的童鞋可以看下玩法流程： APP将玩法最终呈现给用户的是一张张卡片UI，所以我们把每次推送给用户的活动称为「卡牌」。每个卡牌具有不一样的玩法功能和营销意义。 卡牌的出现可以增加一些有趣的逻辑，例如带频道限制的卡牌 - 适用于在不同频道摇出不同的卡片；带时间段限制的卡片 - 可以在不同的时间段、节日摇出不一样的卡片。。。 而至于卡牌内容的设计，嘿嘿，我们可以很乖巧，也可以很邪恶，可以很文艺清新，也可以风骚YD，可以很地方随意，也可以很官方严肃，总之我们努力满足各方要求，不管你是宅男还是欲女！ 在1.4.0版本中，我们只准备了有限的3张卡牌，大伙儿先提前尝尝鲜吧。 成熟性感与完美，需要多给我们一点调教的时间。 尝鲜下载体验 目前仅提供ios版本基于 Weex 的 Android 版与网页版正在紧急开发中，敬请期待。 官网地址：https://app.aotu.io 下载地址： 扫二维码： 问题反馈： 「凹凸实验室」公众号 (AOTULabs) APP 个人中心 -&gt; 设置 -&gt; 意见反馈 希望在这个信息爆炸的时代，「轻氧」能够帮助你聚焦更优质的资讯内容。也让你更加专注于用心被创造出来的文章，和其创造者。","pubDate":"Mon, 21 Nov 2016 05:21:43 GMT","guid":"https://aotu.io/notes/2016/11/21/liteo2-app-tarots/","category":"移动开发"},{"title":"正则表达式理论篇","link":"https://aotu.io/notes/2016/11/17/regexp-theory/","description":"学习正则表达式的你们，有没有发现，一开始总是记不住语法。嗯，加深大家的印象的同时，我也是来找同道中人的。","pubDate":"Thu, 17 Nov 2016 01:29:38 GMT","guid":"https://aotu.io/notes/2016/11/17/regexp-theory/","category":"Web开发"},{"title":"XCel 项目总结 - Electron 与 Vue 的性能优化","link":"https://aotu.io/notes/2016/11/15/xcel/","description":"XCEL 是由京东用户体验设计部凹凸实验室推出的一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。 XCEL 基于 Electron 和 Vue 2.0 进行开发，充分利用 Electron 多进程任务处理等功能，使其拥有高性能、跨平台（windows 7+、Mac 和 Linux）的特性。 落地页：https://xcel.aotu.io/ ✨✨✨项目地址：https://github.com/o2team/xcel ✨✨✨ 项目背景用户研究的定量研究和轻量级数据处理中，均需对数据进行清洗处理，用以剔除异常数据，保证数据结果的信度和效度。目前因调研数据和轻量级数据的多变性，对轻量级数据清洗往往采取人工清洗，缺少统一、标准的清洗流程，但对于调研和轻量级的数据往往是需要保证数据稳定性的，因此，在对数据进行清洗的时候最好有可以标准化的清洗方式。 特性一览 基于 Electron 研发并打包成为原生应用，用户体验良好； 可视化操作 Excel 数据，支持文件的导入导出； 拥有单列运算逻辑、多列运算逻辑和双列范围逻辑三种筛选方式，并且可通过“且”、“或”和“编组”的方式任意组合。 思路与实现结合用研组的需求，我们利用 Electron 和 Vue 的特性对该工具进行开发。 技术选型 Electron：桌面端跨平台框架，为 Web 提供了原生接口的权限。打包后的程序兼容 Windows 7 及以上、Mac、Linux 的 32 / 64 位系统。详情&gt;&gt; Vue 全家桶：Vue 拥有数据驱动视图的特性，适合重数据交互的应用。详情&gt;&gt; js-xlsx：各种电子表格格式的解析器和生成器。纯 JavaScript 实现，适用于 Node.js 和 Web 前端。详情&gt;&gt; 实现思路 通过 js-xlsx 解析 Excel 文件生成 JSON 格式 根据筛选条件对 JSON 数据进行筛选过滤 将过滤后的 JSON 数据生成 js-xlsx 指定的数据结构 利用 js-xlsx 对转换后的数据生成 Excel 文件 纸上得来终觉浅，绝知此事要躬行 相关技术如果对某项技术比较熟悉可略读/跳过。 ElectronElectron 是什么？Electron 是一个能让你通过 JavaScript、HTML 和 CSS 构建桌面应用的框架。这些应用能打包到 Mac、Windows 和 Linux 电脑上运行，当然它们也能上架到 Mac 和 Windows 的 app stores。 JavaScript、HTML 和 CSS 都是 Web 语言，这就意味着它们都是组成网站的一部分，浏览器（如 Chrome）能将这些代码转为可视化图像。 Electron 是一个框架：Electron 对底层代码进行抽象和封装，让开发者能在此之上构建项目。 为什么它如此重要？通常来说，桌面应用都需要用每个操作系统对应的原生语言进行开发。这意味着需要拥有 3 个团队为这个应用编写 3 个相应的版本。Electron 则允许你通过 web 语言编写一次即可。 原生（操作系统）语言：用于开发主流操作系统的应用的原生语言如下（大多数情况下）：Mac 对应 Objective C、Linux 对应 C、Windows 对应 C++。 它由什么组成？Electron 结合了 Chromium、Node.js 和用于调用操作系统本地功能的 API（如打开文件窗口、通知、图标等）。 Chromium：Google 创造的一个开源库，并用于 Google 的浏览器 Chrome。 Node.js（Node）：一个用于在服务器运行 JavaScript 的运行时（runtime），它拥有文件系统和网络的权限（你的电脑也可以是一台服务器！）。 开发体验如何？基于 Electron 的开发，就好像开发一个网页一样，而且能够无缝地 使用 Node。或者说：就好像构建一个 Node app，并通过 HTML 和 CSS 构建界面。另外，你只需为一个浏览器（最新的 Chrome）进行设计（即无需考虑兼容性）。 使用内置的 Node：这还不是全部！除了 Node API，你还可以使用托管在 npm 上，超过 350,000 个的模块。 一个浏览器：并非所有浏览器都提供一致的样式，因此 web 设计师和开发者时常不得不花费更多的精力去让一个网站在不同的浏览器上看起来一致。 最新的 Chrome：可使用超过 90% 的 ES2015 特性和其它很酷的特性（如 CSS 变量）。 两个进程（重点）Electron 有两个种进程：『主进程』和『渲染进程』。有些模块只能工作在其中一个进程上，而有些则能工作在两个进程上。主进程更多地充当幕后角色，而渲染进程则是应用的每个窗口。PS：可通过任务管理器（PC）/活动监视器（Mac）查看进程的相关信息。 模块：Electron 的 API 是根据它们的功能进行分组。例如：dialog 模块拥有所有原生 dialog 的 API，如打开文件、保存文件和弹窗。 主进程主进程，通常是一个命名为 main.js 的文件，该文件是每个 Electron 应用的入口。它控制了应用的生命周期（从打开到关闭）。它能调用原生元素和创建新的（多个）渲染进程，而且整个 Node API 是内置其中的。 调用原生元素：打开 diglog 和其它操作系统交互均是资源密集型操作（注：出于安全考虑，渲染进程是不能直接调用本地资源的），因此都需要在主进程完成。 渲染进程渲染进程是应用的一个浏览器窗口。与主进程不同，它能存在多个（注：一个 Electron 应用只能有一个主进程）并且是相互独立的。它们也能是隐藏的。它通常被命名为 index.html。它们就像典型的 HTML 文件，但在 Electron 中，它们能获取完整的 Node API 特性。因此，这也是它与其它浏览器不同的地方。 相互独立：每个渲染进程都是独立的，这意味着就算它们某个崩溃了，也不会影响其余的渲染进程。 隐藏的：你可以设置一个窗口是隐藏的，然后让它只在背后执行代码（👍）。 把它们想象成这样在 Chrome（或其它浏览器）中的每个标签页（tab） 和其内的页面，就好比 Electron 中的一个单独渲染进程。如果你关闭所有标签页，Chrome 依然存在，这好比 Electron 的主进程，而且你能打开一个新的窗口或关闭这个应用。 注：一般情况下，在 Chrome 浏览器中，一个标签页（tab）中的页面（即除了浏览器本身部分，如搜索框、工具栏等）就是一个渲染进程。 相互通讯尽管主进程和渲染进程都有各自的任务，但它们之间也有需要协同完成的任务。因此它们之间需要通讯。IPC就为此而生，它提供了进程间的通讯。但它只能在主进程与渲染进程之间传递信息。 IPC：主进程和渲染进程都有一个 IPC 模块。 汇成一句话Electron 应用就像 Node 应用，它也依赖一个 package.json 文件。该文件定义了哪个文件作为主进程，并因此让 Electron 知道从何启动你的应用。然后主进程能创建渲染进程，并能使用 IPC 让两者间进行消息传递。 至此，Electron 的基础部分介绍完毕。该部分是基于我之前翻译的一篇文章《Essential Electron》，译文可点击 这里。 Vue 全家桶目前，该工具应用了 Vue、Vuex、Vuex-router。在工具基本定型阶段，由 1.x 升级到了 2.0 （Vuex 暂未升级）。 为什么选择 Vue对于我来说： 简单易用，一般使用只需看官方文档。 数据驱动视图，所以基本不用操作 DOM 了。 框架的存在是为了帮助我们应对复杂度。 全家桶的好处是：对于一般场景，我就不需要考虑用哪些个库（插件）。 Vue 1.x -&gt; Vue 2.0 的版本迁移用 vue-migration-helper 即可分析出大部分需要更改的地方。 网上已经有很多关于 Vue 的信息了。至此，Vue 部分介绍完毕。 js-xlsx该库支持各种电子表格格式的解析和生成。它由纯 JavaScript 实现，适用于前端和 Node。详情&gt;&gt; 支持读入的格式有： Excel 2007+ XML Formats (XLSX/XLSM) Excel 2007+ Binary Format (XLSB) Excel 2003-2004 XML Format (XML “SpreadsheetML”) Excel 97-2004 (XLS BIFF8) Excel 5.0/95 (XLS BIFF5) OpenDocument Spreadsheet (ODS) 支持写的格式有： XLSX CSV (and general DSV) JSON and JS objects (various styles) 只要能提供读（解析）和写，剩下的就是靠 JavaScript 处理解析出来的数据（JSON）了。目前该库提供了 sheet_to_json 方法，该方法能将读入的 Excel 数据转为 JSON 格式。由于导出时需要提供特定的 JSON 格式，因此这部分需要我们自己实现。 更多关于 Excel 在 JavaScript 中处理的知识可关注：凹凸实验室的《Node读写Excel文件探究实践》。但该文章存在两处问题（均在 js-xlsx 实战的导出表格部分）： 生成头部时，Excel 的列信息简单地通过 String.fromCharCode(65+j) 生成，但列大于 26 时就会出现问题。这个问题会在后面章节中给出解决方案； 转换成 worksheet 需要的结构处，出现逻辑性错误，并且会导致严重的性能问题。逻辑问题在此不讲述，我们讲下性能问题：ECMAScript 的不断更新，让 JavaScript 更加强大和易用。尽管如此，我们还是要做到『物尽所用』，而不要『大材小用』，否则会得到反效果。这里导致性能问题的正是 Object.assign() 方法，该方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。由于该方法自身的实现机制，会在这里产生大量的冗余操作。而这里的单元格信息是唯一的，所以直接通过 forEach 为一个空对象赋值即可。提升 N 倍性能的同时，也把逻辑性错误解决了。 原来的：1var result = 某数组.reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123;[next.position]: &#123;v: next.v&#125;&#125;), &#123;&#125;); 改为：1var result = 某数组.forEach((v, i) =&gt; data[v.position]= &#123;v: v.v&#125;) 实践是检验真理的唯一标准在理解上述知识的前提下，下面就谈谈一些在实践中总结出来的技巧、难点和重点。 CSS、JavaScript 和 Electron 相关的知识和技巧高亮 table 的列Excel 单元格采用 table 展示。在 Excel 中，被选中的单元格会高亮相应的『行』和『列』，以提醒用户。在该应用中也有做相应处理，横向高亮采用 tr:hover 实现，而纵向呢？这里所采用的一个技巧是： 假设 HTML 结构如下：1234div.container table tr td CSS 代码如下：12345678910.container &#123; overflow:hidden; &#125;td &#123; position: relative; &#125;td:hover::after &#123; position: absolute; left: 0; right: 0; top: -1个亿px; // 小目标达成，不过是负的😭 bottom: -1个亿px; z-index: -1; // 避免遮住自身和同列 td 的内容、border 等&#125; 斜分割线如图： 分割线可以通过 ::after/::before 伪类元素实现一条直线，然后通过 transform:rotate(); 旋转特定角度实现。但这种实现的一个问题是：由于宽度是不定的，因此需要通过 JavaScript 运算才能得到准确的对角分割线。 因此，这里可以通过 CSS 线性渐变 linear-gradient(to top right, transparent, transparent calc(50% - .5px), #d3d6db calc(50% - .5px), #d3d6db calc(50% + .5px), transparent calc(50% + .5px)) 实现。无论宽高如何变，依然妥妥地自适应。 Excel 的列转换 Excel 的列需要用『字母』表示，但不能简单地通过 String.fromCharCode() 实现，因为当超出 26列 时会产生问题（如：第 27 列，String.fromCharCode(65+26) 得到的是 [，而不是 AA）。因此，这需要通过『十进制和26进制转换』算法来实现。 123456789101112// 将指定的自然数转换为26进制表示。映射关系：[0-25] -&gt; [A-Z]。function getCharCol(n) &#123; let temCol = '', s = '', m = 0 while (n &gt; 0) &#123; m = n % 26 + 1 s = String.fromCharCode(m + 64) + s n = (n - m) / 26 &#125; return s&#125; 1234567891011// 将指定的26进制转换为自然数。映射关系：[A-Z] -&gt;[0-25]。function getNumCol(s) &#123; if (!s) return 0 let n = 0 for (let i = s.length - 1, j = 1; i &gt;= 0; i--, j *= 26) &#123; let c = s[i].toUpperCase() if (c &lt; 'A' || c &gt; 'Z') return 0 n += (c.charCodeAt() - 64) * j - 1 &#125; return n&#125; 为 DOM 的 File 对象增加了 path 属性Electron 为 File 对象额外增了 path 属性，该属性可得到文件在文件系统上的真实路径。因此，你可以利用 Node 为所欲为😈。应用场景有：拖拽文件后，通过 Node 提供的 File API 读取文件等。 支持常见的编辑功能，如粘贴和复制Electron 应用在 MacOS 中默认不支持『复制』『粘贴』等常见编辑功能，因此需要为 MacOS 显式地设置复制粘贴等编辑功能的菜单栏，并为此设置相应的快捷键。 123456789101112131415161718192021222324252627282930313233343536373839404142// darwin 就是 MacOSif (process.platform === 'darwin') &#123; var template = [&#123; label: 'FromScratch', submenu: [&#123; label: 'Quit', accelerator: 'CmdOrCtrl+Q', click: function() &#123; app.quit(); &#125; &#125;] &#125;, &#123; label: 'Edit', submenu: [&#123; label: 'Undo', accelerator: 'CmdOrCtrl+Z', selector: 'undo:' &#125;, &#123; label: 'Redo', accelerator: 'Shift+CmdOrCtrl+Z', selector: 'redo:' &#125;, &#123; type: 'separator' &#125;, &#123; label: 'Cut', accelerator: 'CmdOrCtrl+X', selector: 'cut:' &#125;, &#123; label: 'Copy', accelerator: 'CmdOrCtrl+C', selector: 'copy:' &#125;, &#123; label: 'Paste', accelerator: 'CmdOrCtrl+V', selector: 'paste:' &#125;, &#123; label: 'Select All', accelerator: 'CmdOrCtrl+A', selector: 'selectAll:' &#125;] &#125;]; var osxMenu = menu.buildFromTemplate(template); menu.setApplicationMenu(osxMenu);&#125; 更贴近原生应用Electron 的一个缺点是：即使你的应用是一个简单的时钟，但它也不得不包含完整的基础设施（如 Chromium、Node 等）。因此，一般情况，打包后的程序至少会达到几十兆（根据系统类型进行浮动）。当你的应用越复杂，就越可以忽略这部分了。 众所周知，页面的渲染难免会导致『白屏』，而且这里采用了 Vue 框架，情况就更加糟糕了。另外，Electron 应用也避免不了『先打开浏览器，再渲染页面』的步骤。下面提供几种方法来减轻这种情况，以让程序更贴近原生应用。 指定 BrowserWindow 的背景颜色； 先隐藏窗口，直到页面加载后再显示； 保存窗口的尺寸和位置，以让程序下次被打开时，依然保留的同样大小和出现在同样的位置上。 对于第一点，若程序的背景不是纯白（#fff）的，那么可指定窗口的背景颜色与其一致，以避免突变。1234mainWindow = new BrowserWindow(&#123; title: 'XCel', backgroundColor: '#f5f5f5',&#125;; 对于第二点，由于 Electron 本质是一个浏览器，需要加载非网页部分的资源。因此，我们可以先隐藏窗口。1234var mainWindow = new BrowserWindow(&#123; title: 'ElectronApp', show: false,&#125;; 等到渲染进程开始渲染页面的那一刻，在 ready-to-show 的回调函数中显示窗口。1234mainWindow.on('ready-to-show', function() &#123; mainWindow.show(); mainWindow.focus();&#125;); 对于第三点，我并没有实现，原因如下： 用户一般是根据当时的情况对程序的尺寸和位置进行调整，即视情况而定。 以上是我个人臆测，主要是我懒🐶。 其实现方式，可参考《4 must-know tips for building cross platform Electron apps》。 如何在渲染进程调用原生弹框？在渲染进程中调用原本专属于主进程中的 API （如弹框）的方式有两种： IPC 通讯模块：先在主进程通过 ipcMain 进行监听，然后在渲染进程通过 ipcRenderer 进行触发； remote 模块：该模块提供了一种在渲染进程（网页）和主进程之间进行进程间通讯（IPC）的简便途径。 对于第一种，有需要就在评论区留言； 对于第二种， 在渲染进程中，运行以下代码即可：123456789 const remote = require('electron').remote remote.dialog.showMessageBox(&#123; type: 'question', buttons: ['不告诉你', '没有梦想'], defaultId: 0, title: 'XCel', message: '你的梦想是什么？'&#125; 自动更新如果 Electron 应用没有了自动更新的功能，那么意味着用户想体验你新开发的功能或用上修复 Bug 后的新版本，只能靠自己主动地去官网下载，这无疑是糟糕的体验。Electron 提供的 autoUpdater 模块可实现自动更新功能，该模块提供了第三方框架 Squirrel 的接口，但 Electron 目前只内置了 Squirrel.Mac，且它与 Squirrel.Windows（需要额外引入）的处理方式也不一致（在客户端与服务器端两方面），因此如果刚接触该模块，会发现处理起来相对比较繁琐。具体可以参考我的一篇译文《Electron 自动更新的完整教程（Windows 和 OSX）》。 目前 Electron 的 autoUpdater 模块不支持 Linux 系统。 另外，XCel 目前并没有采用 autoUpdater 模块实现自动更新功能，而是利用 Electron 的 DownloadItem 模块实现。而服务器端则采用 Nuts。 至此，CSS、JavaScript 和 Electron 相关的知识和技巧 部分阐述完毕。 性能优化下面谈谈『性能优化』，这部分涉及到运行效率和内存占用量。注：以下内容均基于 Excel 样例文件（数据量为：1913 行 x 180 列）得出的结论。 执行效率和渲染的优化Vue 性能真的好？Vue 一直标榜着自己性能优异，但当数据量上升到一定量级时（如 1913 x 180 ≈ 34 万个数据单元），会出现严重的性能问题（不做相应优化的前提下）。 如直接通过列表渲染 v-for 渲染数据时，会导致程序卡死。答：通过查阅相关资料可得（猜测）， v-for 是通过一条条数据在构建后插入 DOM 的，这对于数据量较大时，无疑会造成严重的性能问题。 当时，我想到了两种解决思路： Vue 是数据驱动视图的，对数据分段 push，即将一个庞大的任务分割为 N 份。 自己拼接 HTML 字符串，再通过 innerHTML 一次性插入。 最终，我选择了第二条，理由是： 性能最佳，因为每次执行数据过滤时，Vue 都要进行 diff，性能不佳。 更符合当前应用的需求：纯展示且无需动画过渡等。 实现更简单 将原本繁重的 DOM 操作转移到了 JavaScript 的拼接字符串后，性能得到了很大提升（不会导致程序卡死而渲染不出视图）。这种实现原理难道不就是 Vue、React 等框架解决的问题之一吗？只不过框架考虑的场景更广，有些地方需要我们自己根据实际情况进行优化而已。 在浏览器当中，JavaScript 的运算在现代的引擎中非常快，但 DOM 本身是非常缓慢的东西。当你调用原生 DOM API 的时候，浏览器需要在 JavaScript 引擎的语境下去接触原生的 DOM 的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实 DOM 的操作是最少的。 —— 《Vue 2.0——渐进式前端解决方案》 当然，由于 JavaScript 天生单线程，即使执行数速度再快，也会导致页面有短暂的时间拒绝用户的输入。此处可通过 Web Worker 或其它方式解决，这也将是我们后续讲到的问题。 也有网友提供了优化大量列表的方法：https://clusterize.js.org/。 但在这里我并没有采用此方式。 强大的 GPU 加速插入 DOM 后，又会出现了另外一个问题：滚动会很卡。猜想这是渲染问题，毕竟 34 万个单元格同时存在于界面中。 添加 transform: translate3d(0, 0, 0) / translateZ(0) 属性启动 GPU 渲染，即可解决这个渲染性能问题。再次感叹该属性的强大。🐂 后来，考虑到用户并不需要查看全部数据，只需展示部分数据让用户进行参考即可。我们对此只渲染前 30/50 行数据。这样即可提升用户体验，也能进一步优化性能（又是纯属臆测）。 记得关闭 Vuex 的严格模式另外，由于自己学艺不精和粗心大意，忘记在生产环境关闭 Vuex 的『严格模式』。Vuex 的严格模式要在生产中关闭，否则会对 state 树进行一个深观察 (deep watch)，产生不必要的性能损耗。也许在数据量少时，不会注意到这个问题。 我当时的情况是：导入 Excel 数据后，再进行交互（涉及 Vuex 的读写操作），则需要等几秒才会响应，而直接通过纯 DOM 监听的事件则无此问题。由此，判断出是 Vuex 问题。 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV !== 'production'&#125;) 多进程！！！前面说道，JavaScript 天生单线程，即使再快，对于需要处理数据量较大的情况，也会出现拒绝响应的问题。因此需要 Web Worker 或类似的方案去解决。 在这里我不选择 Web worker 的原因有如下几点： 有其它更好的替代方案：一个主进程能创建多个渲染进程，通过 IPC 即可进行数据交互； Electron 不支持 Web Worker！ Electron 作者在 2014.11.7 在《state of web worker support?》 issue 中回复了以下这一段： Node integration doesn’t work in web workers, and there is no plan to do. Workers in Chromium are implemented by starting a new thread, and Node is not thread safe. Back in past we had tried to add node integration to web workers in Atom, but it crashed too easily so we gave up on it. 因此，我们最终采用了创建一个新的渲染进程 background process 进行处理数据。由 Electron 章节可知，每个 Electron 渲染进程是独立的，因此它们不会互相影响。但这也带来了一个问题：它们不能相互通讯？ 错！下面有 3 种方式进行通讯： Storage API：对某个标签页的 localStorage/sessionStorage 对象进行增删改时，其他标签页能通过 window.storage 事件监听到。 IndexedDB：IndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。 通过主进程作为中转站：设主界面的渲染进程是 A，background process 是 B，那么 A 先将 Excel 数据传递到主进程，然后主进程再转发到 B。B 处理完后再原路返回，具体如下图。当然，也可以将数据存储在主进程中，然后在多个渲染进程中使用 remote 模块来访问它。 该工具采用了第三种方式的第一种情况： 1、主页面渲染进程 A 的代码如下：1234567891011//①ipcRenderer.send('filter-start', &#123; filterTagList: this.filterTagList, filterWay: this.filterWay, curActiveSheetName: this.activeSheet.name&#125;)// ⑥ 在某处接收 filter-response 事件ipcRenderer.on(\"filter-response\", (arg) =&gt; &#123; // 得到处理数据&#125;) 2、作为中转站的主进程的代码如下：12345678910//②ipcMain.on(\"filter-start\", (event, arg) =&gt; &#123; // webContents 用于渲染和控制 web page backgroundWindow.webContents.send(\"filter-start\", arg)&#125;)// ⑤ 用于接收返回事件ipcMain.on(\"filter-response\", (event, arg) =&gt; &#123; mainWindow.webContents.send(\"filter-response\", arg)&#125;) 3、处理繁重数据的 background process 渲染进程 B 的代码如下：12345678910// ③ipcRenderer.on('filter-start', (event, arg) =&gt; &#123; // 进行运算 ... // ④ 运算完毕后，再通过 IPC 原路返回。主进程和渲染进程 A 也要建立相应的监听事件 ipcRenderer.send('filter-response', &#123; filRow: tempFilRow &#125;)&#125;) 至此，我们将『读取文件』、『过滤数据』和『导出文件』三大耗时的数据操作均转移到了 background process 中处理。 这里，我们只创建了一个 background process，如果想要做得更极致，我们可以新建『CPU 线程数- 1 』 个的 background process 同时对数据进行处理，然后在主进程对处理后数据进行拼接，最后再将拼接后的数据返回到主页面的渲染进程。这样就可以充分榨干 CPU 了。当然，在此我不会进行这个优化。 不要为了优化而优化，否则得不偿失。 —— 某网友 内存占有量过大解决了执行效率和渲染的问题，发现也存在内存占用量过大的问题。当时猜测是以下几个原因： 三大耗时操作均放置在 background process 处理。在通讯传递数据的过程中，由于不是共享内存（因为 IPC 是基于 Socket 的），导致出现多份数据副本（在写该篇文章时才有了这相对确切的答案）。 Vuex 是以一个全局单例的模式进行管理，但它会是不是对数据做了某些封装，而导致性能的损耗呢？ 由于 JavaScript 目前不具有主动回收资源的能力，所以只能主动对闲置对象设置为 null，然后等待 GC 回收。 由于 Chromium 采用多进程架构，因此会涉及到进程间通信问题。Browser 进程在启动 Render 进程的过程中会建立一个以 UNIX Socket 为基础的 IPC 通道。有了 IPC 通道之后，接下来 Browser 进程与 Render 进程就以消息的形式进行通信。我们将这种消息称为 IPC 消息，以区别于线程消息循环中的消息。——《Chromium的IPC消息发送、接收和分发机制分析》 定义：为了易于理解，以下『Excel 数据』均指 Excel 的全部有效单元格转为 JSON 格式后的数据。 最容易处理的无疑是第三点，手动将不再需要的变量及时设置为 null。但这效果并不明显。 后来，通过系统的『活动监视器』对该工具的每阶段（打开时、导入文件时、筛选时和导出时）进行粗略的内存分析，得到以下报告（之前分析的、未作修改）： —————- S：报告分割线 —————-经观察，主要耗内存的是页面进程。下面通过截图说明：PID 15243 是主进程PID 15246 是页面渲染进程PID 15248 是 background 渲染进程 a、首次启动程序时（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ） b、导入文件（第 5 行是主进程；第 2 行是页面渲染进程；第 4 行是 background 渲染进程 ） c、筛选数据（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ） 由于 JS 目前不具有主动回收资源的功能，所以只能主动将对象设置为 null，然后等待 GC 回收。 因此，经过一段时间等待后，内存占用如下：d、一段时间后（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ） 由上述可得，页面渲染进程由于页面元素和 Vue 等 UI 相关资源是固定的，占用内存较大且不能回收。主进程占用资源也不能得到很好释放，暂时不知道原因，而 background 渲染进程则较好地释放资源。 —————- E：报告分割线 —————- 根据报告，初步得出的结论是 Vue 和通讯时占用资源较大。 根据该工具的实际应用场景：由于 Excel 数据只在『导入』和『过滤后』两个阶段需要展示，而且展示的只是通过 JavaScript 拼接的 HTML 字符串构成的 DOM 而已。因此将表格数据放置在 Vuex 中，有点滥用资源的嫌疑。 另外，在 background process 中也有存有一份 Excel 数据副本。因此，索性只在 background process 存储一份 Excel 数据，然后每当数据变化时，通过 IPC 让 background process 返回拼接好的 HTML 字符串即可。这样一来，内存占有量立刻下降许多。而且这也是一个一举多得的优化： 字符串拼接操作也转移到了 background process，页面的渲染进程进一步减少耗时的操作； 内存占有量大大减小，响应速度也得到了提升。 其实，这也有点像 Vuex 的『全局单例模式管理』，一份数据就好。 当然，对于 Excel 的基本信息，如行列数、SheetName、标题组等均依然保存在 Vuex。 优化后的内存占有量如下图。与上述报告的第三张图相比（同一阶段），内存占有量下降了 44.419%：另外，对于不需要响应的数据，可通过 Object.freeze() 冻结起来。这也是一种优化手段。但该工具目前并没有应用到。 至此，优化部分也阐述完毕了！ 该工具目前是开源的，欢迎大家使用或推荐给用研组等有需要的人。 你们的反馈（可提交 issues / pull request）能让这个工具在使用和功能上不断完善。 最后，感谢 LV 的产品规划、界面设计和优化上的强力支持。全文完！","pubDate":"Tue, 15 Nov 2016 15:23:23 GMT","guid":"https://aotu.io/notes/2016/11/15/xcel/","category":"项目总结"},{"title":"漫漫编程路上必读的7本书","link":"https://aotu.io/notes/2016/11/14/booklist-for-every-programmer/","description":"7本对提升程序员编程思想、软件工程理论大有裨益的通用读物，不分专业，不分语言，不分排名先后。 Code Complete中文版叫『代码大全』，两届SoftwareJolt Award震撼大奖得主，一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。 谷歌度娘搜关键字「程序员必读书本」的结果统计，这本书是最多人推荐的，近年宣称为「最值得程序员阅读的首本书，也是建议程序员推荐给身边小伙伴的首本书」。 想读的朋友可以到我东东家购买， 代码大全（第2版 英文版） 代码大全（第2版 中文版） The Pragmatic Programmer - From Journeyman to Master中文版叫『程序员修炼之道-从小工到专家』。 原版略贵但绝对值的一读，它充满了关于如何改进程序员本身和代码本身的实用建议。 想读的朋友依然可以到我东东家购买，原版有每满100减30的活动。 程序员修炼之道 英文版） 程序员修炼之道（第2版 中文版） The Mythical Man-Month: Essays on Software Engineering有一个好的中文名叫『人月神话』。 引用东东家的一段广告语吧： 图灵奖得主，IBM 360系统之父，作者Brooks颠覆了项目管理领域，长久不衰传奇著作！软件开发人员、软件项目经理、系统分析师等IT从业者必藏之软工圣经，畅销40年！赠国内实战体验精华册 然后摘其中的两句经典： 生一个孩子总是需要九个月的时间，不管安排多少个女性。一个煎蛋，承诺在两分钟内完成，但如果两分钟后还是没有准备好，那么客户有两种选择——等待或吃半熟品，软件客户也只能这样选择。 正从标题中所说的那样，这是一本关于软件工程的散文集，文辞优美。唯一的缺点就是引用了年迈的古老技术，但是，这并不影响这本书的魅力。 是时候入手一本经典书籍了： 人月神话 英文版） 人月神话（40周年中文纪念版） Structure and Interpretation of Computer Programs中文名叫『计算机程序的构造和解释』，目测应该是一本计算机科学的科普读物。 京东购买地址： 计算机程序的构造和解释 英文版） 计算机程序的构造和解释 原书第2版 Head First Design Patterns看着封面的妹子就想读的一本书，中文名叫『Head Frirst 设计模式』。 看上去最不像技术的编程书籍！ 每个页面都包含涂鸦、图片以及其他一些吸引眼球的东西。 可能给人的印象是一本阅读起来很轻松的书，但事实上它会讨论编程的一些核心主题 —— 设计模式。 设计模式就是编程世界里的各种抽象的定理，而这本书有把它们画出来、具体化了的感觉。 畅销十年，累计印刷30余次，荣获2005年第十五届Jolt通用类图书震撼大奖！买买买！ Head Frirst 设计模式 英文版） O’Reilly：Head First设计模式（中文版） Introduction to Algorithms中文名叫『算法导论』，这是今天介绍的几本书里面唯一一本关于「算法」的。 超过50万人阅读的算法圣经！算法标准教材，国内外1000余所高校采用! 京东购买地址： 算法导论 英文版） 算法导论（中文版） The Clean Coder最后一本是关于程序员职业素养的书，中文名为『程序员的职业素养』。 该书探讨了一些程序员经常忽视的主题。 成为专业的程序员意味着什么？ 如何打磨自己成为一个真正的软件工匠？ 冲突和紧张的日程处理 如何管理你的时间？如何扩张技能？ 何时说“不” 避免倦怠 ..以及更多。 你可能并不总是同意作者的观点，但它提供了良好的精神食粮。这可能并非你所期望的，但可能正是你所需要的。 京东购买地址： 程序员的职业素养 英文版） 程序员的职业素养 中文版 参考资料 Stackoverflow: What is the single most influential book every programmer should read? Recommended Reading for Developers 12 Most Influential Books Every Software Engineer Needs to Read 10 Classic Books Every Serious Developer Should Read 每个程序员应该阅读的10本经典书籍","pubDate":"Mon, 14 Nov 2016 08:21:43 GMT","guid":"https://aotu.io/notes/2016/11/14/booklist-for-every-programmer/","category":"资源合集"},{"title":"Webpack 实用配置技巧","link":"https://aotu.io/notes/2016/11/14/webpack-tips/","description":"前言Webpack做了什么 一句话简单来解释就是处理模块依赖，并将它们合并成可用的静态资源。 为什么选Webpack 模块打包工具有很多，Webpack的特点是它依赖的模块可以是js文件，也可以是css文件，只要配置对应的webpack-loader(加载器)，.coffee、.sass、.jade等等任意的静态资源文件都可以被引用，并解析。 例如：我在项目中使用Vue框架，在配置官方提供的loader后，就可以直接在js中依赖.vue后缀的单文件组件了。 上手安装 使用npm init命令来创建一个package.json文件 安装Webpack，推荐只安装在当前项目中作为依赖 npm install webpack –save 添加一个配置文件 webpack.config.js module.exports = { entry: &quot;./entry.js&quot;, output: { path: __dirname, filename: &quot;bundle.js&quot; }, module: { loaders: [ { test: /\\.css$/, loader: &quot;style!css&quot; } ] } }; 执行webpack命令 如果全局安装了Webpack的话,那么直接在当前项目执行webpack命令就可以依赖上述webpack.config.js文件中的配置，分析entry.js中的依赖，打包输出bundle.js 我使用npm scripts来启动任务，在package.json中添加： { ... &quot;scripts&quot;: { &quot;build&quot;: &quot;NODE_ENV=production webpack --watch&quot; } ... } 执行npm run build。其中–watch参数表示持续的监听文件变化进行打包。 入口文件配置配置多个入口文件 module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;[name].js&quot; }, module: { loaders: [ { test: /\\.css$/, loader: &quot;style!css&quot; } ] } }; 在这个配置文件中有两个入口文件，输出的时候[name]会被替换为入口中配置的entry1_bundle和entry2_bundle 使用glob方式配置 var path = require(&apos;path&apos;), glob = require(&apos;glob&apos;) //需安装glob模块依赖 function getEntries (globPath) { var files = glob.sync(globPath); var _entries = {}, entry, dirname, basename; for (var i = 0; i &lt; files.length; i++) { entry = files[i]; dirname = path.dirname(entry); basename = path.basename(entry, &apos;.js&apos;); _entries[path.join(dirname, basename)] = &apos;./&apos; + entry; } return _entries; } 执行getEntries(‘*.js’)就会遍历到目录下全部的js文件做为入口文件配置。 使用插件目前我有用到三个插件：CommonsChunkPlugin，UglifyJsPlugin，以及一个我自己定义的插件 module.exports = { // plugins 字段传入一个数组，里面是实例化后的各种插件 plugins: [new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, minChunks: 3 }), new webpack.optimize.UglifyJsPlugin([options]), ... ], entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, ... }; 提取公用资源 为了便于使用缓存，我通过CommonsChunkPlugin这个插件将公用部分提取出来。 上述配置会自动的将被3个及以上入口文件引用的资源提取出来到一个新的文件vendor.js中。我们通常不希望公用的内容发生不预知的变化，这样配置就可以将希望提取出来的内容显性的配置在config文件中： entry: { vendor: [&quot;vue&quot;, &quot;other-lib&quot;], ... } new CommonsChunkPlugin({ name: &quot;vendor&quot;, // 将minChunks设置为无穷大，就不会有不期望的内容进入vendor了 minChunks: Infinity, }) 只在生产环境下启用UglifyJs插件 var plugins = [new webpack.optimize.CommonsChunkPlugin([options])] // npm scripts 配置的参数可以用上了 if(process.env.NODE_ENV == &apos;production&apos;){ plugins.push(new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } })) } 关于UglifyJs的使用就不介绍了，参考UglifyJS2。 自定义插件 Webpack提供的插件已足够使用，不过针对不同的业务，我们可能需要定制一些功能，例如我所定制的功能就是在编译资源的同时生成一份用于上传到服务器的md5版本号配置文件。 来一个简单的小栗子，如何开始写一个Webpack插件： var chunkCombo = function(){}; chunkCombo.prototype.apply = function(compiler, callback){ compiler.plugin(&quot;emit&quot;, function(compilation, callback){ compilation.chunks.map(function(chunk, key){ var filename = chunk.name + &apos;.shtml&apos;; var content = chunk.hash.slice(0,8); // 生成一个对应的新文件存储md5值 compilation.assets[filename] = { source: function() { return content; }, size: function() { return Buffer.byteLength(content, &apos;utf8&apos;) } }; }) callback(); }); } 随着项目的深度定制和优化，我们可能需要开发更多的插件。 配置loaders有了无所不能的加载器，Webpack可以处理任何类型的静态文件 module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;[name].js&quot; }, module: { loaders: [ { test: /\\.vue$/, loader: &apos;vue-loader&apos; }, { test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; }, { test: /\\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot;}, //加载器之间用！连接，-loader可以省略不写 { test: /\\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;}, { test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;} ] } }; 加载器使用前记得先通过npm安装对应的模块，并将依赖添加到package.json文件中，例如： npm install vue-loader --save vue-loader用于解析.vue单文件组件。 有了babel-loader就可以直接使用新的语法特性了。Babel的配置参见Using Babel 使用webpack-dev-serverwebpack-dev-server是一个轻量的node.js Express服务，通过Socket.IO来实时的通知客户端Webpack编译状态。安装webpack-dev-server模块，此处不再重复，直接看配置文件： module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;bundle.js&quot; }, ... devServer: { // serve 的根目录 contentBase: _contentBase, port: 9000, // iframe模式和inline模式可选 inline: true， ... } }; 在package.json中添加： { ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;NODE_ENV=dev webpack-dev-server&quot; } ... } 执行npm run dev 命令后，服务就启动了。访问http://localhost:9000，就可以看到你的应用了。 定制Express路由 在inline模式下，需要手动的将用于更新的的脚本引入到页面中： module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;bundle.js&quot; }, ... devServer: { // serve 的根目录 contentBase: _contentBase, port: 9000, // iframe模式和inline模式可选 inline: true, setup: function(app) { app.use(function(req, res, next) { //... return next(); }); app.get([&apos;*.shtml&apos;,&apos;*.html&apos;], function(req, res, next) { //... //将实时更新的脚本引入到页面中 res.end(&apos;&lt;script src=&quot;http://localhost:9000/webpack-dev-server.js&quot;&gt;&lt;/script&gt;&apos;) }) } } }; 关于Express路由的使用，参考Express Routing 在我的项目中，我希望HTML页面在开发环境下和服务器环境下保持一致，因此我在devServer中配置了对HTML页面的解析。 以上，希望我的Webpack项目配置能对你解决相关问题的时候有所帮助和启发。 参考资料 Webpack docs Express Routing 使用npm scripts替代gulp","pubDate":"Mon, 14 Nov 2016 08:16:31 GMT","guid":"https://aotu.io/notes/2016/11/14/webpack-tips/","category":"Web开发"},{"title":"WeUI for 小程序 - 为微信小程序量身设计","link":"https://aotu.io/notes/2016/11/10/weui-wxss/","description":"官人你没有走错地方，「WeUI」正式开始支持小程序啦，这是新鲜火辣的、微信官方设计团队为微信小程序量身设计的「WeUI-WXSS」。 概述WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含button、cell、dialog、 progress、 toast、article、actionsheet、icon等各式元素。 视觉标准weui-design 预览用微信web开发者工具打开dist目录 使用 组件的wxml结构请看dist/example/下的组件 样式文件可直接引用dist/style/weui.wxss，或者单独引用dist/style/widget下的组件的wxss LicenseThe MIT License(http://opensource.org/licenses/MIT) 请自由地享受和参与开源 贡献如果你有好的意见或建议，欢迎给我们提issue或pull request，为提升微信web体验贡献力量。","pubDate":"Thu, 10 Nov 2016 09:21:43 GMT","guid":"https://aotu.io/notes/2016/11/10/weui-wxss/","category":"Web开发"},{"title":"轻氧 - 2016年末最新款互联网专业资讯 APP","link":"https://aotu.io/notes/2016/11/09/liteo2-app/","description":"又是一年的双11，大家都在割肾剁手买买买，我们凹凸实验室「阿尔法APP突击队」在抖腿码码码。抬价而后打折促销的商家都TMD是《无耻的混蛋》昆丁.2009，而我们只做良心的促销： 一款免费实用开源的APP轻氧 是 凹凸实验室 一不留神上架了的一款互联网技术资讯APP，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一口气把业界最优质的文章读完，只要你愿意。 其实市面上互联网技术资讯这块领域已经有非常多优秀的产品了，例如开发者头条，又如后来居上者 掘金，类似产品之间的竞争异常剧烈，举步唯艰，再做一款类似内容的APP的意义到底有多少，而成功的概率又有多少？ 我们曾经纠结过这些问题，但后来觉得这些纠结有点傻~ 做轻氧的『初心』本来就不是超越，而是在积累和探索。 从业务的层面来看，是为团队积累和探索一款APP从零到设计到上架的整个流程，为下一次（如果有的话）APP研发需求做好流程和技术上的准备。 从专业技术的层面来看，我们是在努力拓宽自己的专业范畴，要知道凹凸这个团队的前身是前端团队，相对匮乏原生应用开发经验，如果团队技术的努力方向是多终端技术体系，是全栈，那末轻氧APP则是印证我们朝这个方向发展、具备全栈开发综合能力的结果。 我们像是在练武，轻氧是我们自创的一门渐进式的武学，谁都无法断言它的厉害与否，因为主创们在不断的努力摸索和改进。 我们没有忘记O2的口号是：Open Oriented，所以「轻氧」年后将会开源，并配套一本总结整个APP项目从零到上架的书籍，记录着轻氧从无到有的套路和心法。希望能帮助到那些想了解和掌握Swift编程、Sketch设计、以及数据库架构及设计相关技能的同学们。 授之以鱼不如授之以渔，为「轻氧」存在的最大意义。 源码届时将托管在github.com/o2team/app，欢迎抢先点赞订阅更新。 致潜在的用户「轻氧」适合什么样的你呢？ 如果你是辣么专情的： 程序员、设计师、产品经理、运营、用研。 但又不失滥情的闷骚： 喜欢搞搞数码搞机、喜欢新鲜应用、脑袋发热准备创业。 那么，这款资讯 App 就是专门为你设计的。 我们为互联网人士准备了多个专业资讯频道，将优质资讯分类呈现。 你可以根据需要选择你喜欢的频道来定制APP的内容。 目前已开通 11 个资讯频道 （一些好玩的频道正在筹备中）： 总之，「轻氧」旨在帮你严肃地提升学术、视界的同时，也可以让你开个小差去猎奇酷玩，嘿嘿。 丰富的资讯源关于APP的内容源，除了凹凸实验室原创资讯外， 我们精心选出了一些知名的 UED 和互联网站点，基于其简易信息聚合协议（RSS），将优质的互联网内容包装和分发，聚集到一个平台。 我们搬运但不盗窃，如果你喜欢，你仍然可以把「轻氧」当成是一款RSS订阅器，尽管我们不止于订阅辣么简单，后续我们APP做开源分享的时候再做深入介绍。 经过一段时间的耕耘，目前已有超过 4k 篇资讯，来自于 40+ 资讯来源： 未来，我们还将在保证高质量文章的基础上，聚合更多的来源。 看你喜欢看的就像其它资讯平台一样，「轻氧」的每篇文章也被打上了标签。用户可以根据标签或者来源，能筛选出自己喜欢的内容，定制个性化的时间线。 技术驱动研发与一般的资讯 APP 不同的是，这是一款「技术驱动」的APP，它的诞生源于「工科男」心底纯粹的技术欲望，尽管主创之一是兽医出身。 于是两三个技术工程师包揽了从产品构思、基于 Flinto 的原型交互、基于 Sketch 的视觉设计（除了LOGO为一个视觉美眉支持外）、基于 Swift3.x 的编码实现，当然还有 LeanCloud 数据服务的应用，Linux 服务器运维，以及应用上架部署的所有工作。 这肯定不是一款完美的产品，但我们在不停的迭代完善。 为了进一步提升APP的整体体验、提升我们工程师在跨专业领域的专业度，下一个大版本计划会邀请专业的交互设计师、视觉设计师参与进来。 实验性的UI交互在「轻氧」APP里面，我们无所不能为，实验了一些我们YY觉得酷的体验，例如阅读进度记录、卡片频道。尽管新奇不一定是最合适的，但还是期待能给使用「轻氧」的你带来不一样的资讯阅读体验。 尝鲜下载体验 目前仅提供ios版本基于 React Native 的 Android 版与网页版正在紧急开发中，敬请期待。 官网地址：https://app.aotu.io 下载地址： 扫二维码： 问题反馈： 「凹凸实验室」公众号 (AOTULabs) APP 个人中心 -&gt; 设置 -&gt; 意见反馈 希望在这个信息爆炸的时代，「轻氧」能够帮助你聚焦更优质的资讯内容。也让你更加专注于用心被创造出来的文章，和其创造者。","pubDate":"Wed, 09 Nov 2016 06:21:43 GMT","guid":"https://aotu.io/notes/2016/11/09/liteo2-app/","category":"移动开发"},{"title":"深入了解font-weight","link":"https://aotu.io/notes/2016/11/08/css3fontweight/","description":"问题提出font-weight的属性值有100、200、300、400、500、600、700、800、900和normal、bold、lighter、bolder，它们的区别是？另外，在实际开发中，我们应该使用数值表达还是文字表达呢？ 认识font-weight根据W3C Fonts节章的规范标准，可知： font-weight可取值：100～900和normal、bold、bolder、lighter。 100～900、normal、bold如果字体使用九阶有序数值100～900来划分其字重(字体的粗细度)，那么样式指定的font-weight属性值与字体的字重则一一对应。并且normal等价于400，bold等价于700。但实际上，我们一般遇到的字体很多时候都是使用一些通用的词描述划分其字重，如下所示。 常见的字重数值大致对应的字重描述词语： 100 - Thin 200 - Extra Light (Ultra Light) 300 - Light 400 - Regular (Normal、Book、Roman) 500 - Medium 600 - Semi Bold (Demi Bold) 700 - Bold 800 - Extra Bold (Ultra Bold) 900 - Black (Heavy) 为什么说大致对应呢？在有些字库下是有差异的，比如在Adobe Typekit字库中对字重描述的划分列表中，它列出Heavy指的是800而不是900。另外，在我们日常使用的Photoshop和Sketch里面，Ultra Light是100，而Thin是200。 并且，字体所拥有的字重的数量实际上很少存在满足有9个字重刚好跟100～900的CSS字重一一对应的情况，通常字体拥有的字重数量为4至6个。不必担心，起码400和700对应的字重至少是每种字体必备的，譬如常见的 Arial、Helvetica、Georgia等等，只有400(normal)和700(bold)。 bolder、lighterbolder、lighter表示其字重值是基于从其父元素继承而来的字重计算所得的，与normal、bold所代表的字重并无关系。 其值通常是根据下表计算而得的： 继承值（Inherited value） bolder所代表的字重 lighter所代表的字重 100 400 100 200 400 100 300 400 100 400 700 100 500 700 100 600 900 400 700 900 400 800 900 700 900 900 700 字体匹配算法在上面我们已经提到，在很多情况下，字体并不是以九阶数值来划分的，并且其含有的字重数量是不一的，通常情况下为4-6个。 此时，就会出现样式指定的字重数值在字体中找不到直接对应的字重，那浏览器是如何解决的呢？ Bingo！那就是要靠字体匹配算法来解决。其中关于font-weight部分是这么提及到的： 讲人话就是：如果指定的font-weight数值，即所需的字重，能够在字体中找到对应的字重，那么就匹配为该对应的字重。否则，使用下面的规则来查找所需的字重并渲染： 如果所需的字重小于400，则首先降序检查小于所需字重的各个字重，如仍然没有，则升序检查大于所需字重的各字重，直到找到匹配的字重。 如果所需的字重大于500，则首先升序检查大于所需字重的各字重，之后降序检查小于所需字重的各字重，直到找到匹配的字重。 如果所需的字重是400，那么会优先匹配500对应的字重，如仍没有，那么执行第一条所需字重小于400的规则。 如果所需的字重是500，则优先匹配400对应的字重，如仍没有，那么执行第一条所需字重小于400的规则（感谢@浅夏莜韵的指正）。 感谢来自@何洋的补充：大多数浏览器已实现font-synthesis属性，使用该属性可以控制在font-weight没有相匹配的font typeface时，会模拟计算出合适的渲染字重(与其应有的typeface有些差异)，从而忽略Font Matching Algorithm。参考文章： Fonts－字体匹配算法第5条 MDN－font-synthesis 理解与运用下面我们通过官方例子和实际测试来好好理解这个匹配算法规则。 官方例子W3C规范标准中给出这么一个例子： 注解：灰色标记的是字体中缺少的字重，而黑色则是字体拥有的字重。 基于匹配算法规则，看图理解所得：Figure 15.图指的是 字体库内直接匹配的字重 填空值(即通过算法间接匹配所得字重) 400 300、200、100、500 700 600 900 800 拿font-weight: 300;来说，字体中没有可以直接匹配的字重，那么300小于400，则根据第一条规则，先降序查找匹配，但是都没有可匹配的200、100，那么升序查找为400，结果可匹配。 Figure 16.图指的是 字体库内直接映射的字重 填空值 300 200、100、400、500 600 700、800、900 这里需要注意的是，填空值500表现的是300的字重，而不是600的字重。为什么呢？根据规则，500优先匹配400的字重，但是此处找不到400的字重，则执行规则中第一条所需字重小于400的情况。 其余的，我就不多解释了，大家可以根据结果检查自己是否理解到位。 实际测试——Droid Sans 根据Google Fonts API - Droid Sans提供的Droid Sans字体，我们可以知道该字体拥有两种字重。 根据字体匹配算法规则，我们可以预测其字重匹配应该如下表所示： 字体库内直接映射的字重 填空值 400 300、200、100、500 700 600、800、900 也就是100、200、300、500会表现为跟400同一种字重，600、800、900会表现为跟700同一种字重。 利用Google Fonts提供的Droid Sans，我们进行了实例测试－(DroidSans.html)来验证。结果如下图，证明我们的预测结果正确，该字体匹配算法规则运行有效。 总结根据以上的研究，可以总结出三点： 通常情况下，一个特定的字体仅会包含少数的可用字重。若所指定的字重不存在直接匹配，则会通过字体匹配算法规则匹配使用邻近的可用字重。这也就是为什么我们有时候使用特定字重时没有“生效”，看起来跟其它字重差不多的原因所在。 在实际中，最为常用的字重是normal和bold。我个人认为400、700是等效于normal、bold的，无论哪一种表示方法都没有关系，主要是个人习惯问题。 但是，推荐使用数值替代lighter、bolder，因为这涉及到继承计算的问题，用数值的话则会更为清晰明了。 参考资料：W3C－字体W3C－字体匹配算法","pubDate":"Tue, 08 Nov 2016 08:34:58 GMT","guid":"https://aotu.io/notes/2016/11/08/css3fontweight/","category":"Web开发"},{"title":"我的第一次移动端页面制作 — 总结与思考","link":"https://aotu.io/notes/2016/11/08/first-mobile-rebuild/","description":"最近被分配到移动端开发组，支持某活动的页面页面制作。这算是我第一次真正接触移动端页面制作，下面就谈谈个人总结和思考。 整体流程开会大体讲解、讨论与排期 -&gt; 交互设计 -&gt; 视觉设计 -&gt; 页面页面制作 -&gt; 前端开发 -&gt; 测试 每个步骤环环相扣，每个职位都需要和其前后的人沟通协调。 测试遇到问题则会反馈到相应环节负责人。 当然，涉及的职位也不仅于此，还有法务同事审核内容是否符合当前法规等等。 构建工具Athena前端开发离不开构建工具，除了敲代码，其余都交给构建工具（如组件开发、CSS 兼容处理、图片 Base64、图片雪碧图和压缩处理等）。在 Athena 中，文件层级结构如下：项目 project -&gt; 模块 module（具体每个活动） -&gt; 页面 page -&gt; 部件 widget。 举例： 某项目 -&gt; X、Y 活动 -&gt; 预热页和高潮页 -&gt; 头部、弹框等 widget。一般文件目录如下：123456789101112Xproject - gb (公共部分，如初始化样式和一些常用 widget) - X活动 - page - 预热页 - 高潮页 - widget - header - footer - diglog - Y 活动 - ... 刚开始接触时，存在这样的一个疑惑：什么是 widget，一个不可复用的页面头部可以作为 widget 吗？答：我最初的想法是：“错误地把 widget 当成 component，component 一直被强调的 特性之一是可复用性。对于不可复用的部分就不应该抽出为一个widget了？”其实对于一个相对独立的功能，我们就可把它抽出来。这无疑会增强程序的可维护性。 对于一个项目，一般一个模块由一个人负责。但考虑到每个模块间可能存在（或未来存在）可复用的 widget，需要规范命名以形成命名空间，防止冲突（具体会在下面的规范-命名中阐述）。 Component 与 Widget 的区别Component 是更加广义抽象的概念，而Widget是更加具体现实的概念。所以Component的范围要比Widget大得多，通常 Component 是由多个 Widget 组成。举个例子，可能不是很恰当，希望帮助你的理解，比如家是由床，柜子等多个 Component 组成，柜子是由多个抽屉 Widget 组成的。而 Component 和 Widget 的目的都是为了模块化开发。 其实，在这里并没有对 widget 和 component 做这么细的区分。 规范widget正如上面讨论的，一个页面由多个 widget 组成。因此，一个页面看起来如下：123456789101112131415161718192021&lt;body ontouchstart&gt; &lt;div class=\"wrapper\"&gt; &lt;!-- S 主会场头部 --&gt; &lt;%= widget.load(\"app_market_main_header\") %&gt; &lt;!-- E 主会场头部 --&gt; &lt;!-- S 达人问答区 --&gt; &lt;%= widget.load(\"app_market_answer\") %&gt; &lt;!-- E 达人问答区 --&gt; &lt;!-- S 优惠券 --&gt; &lt;%= widget.load(\"app_market_coupons\") %&gt; &lt;!-- E 优惠券 --&gt; &lt;!-- S 达人集中营 --&gt; &lt;%= widget.load(\"app_market_camp\") %&gt; &lt;!-- E 达人集中营 --&gt; &lt;!-- S 达人穿搭公式 --&gt; &lt;%= widget.load(\"app_market_collocation\") %&gt; &lt;!-- E 达人穿搭公式 --&gt; &lt;!-- S 卡券相关弹框 --&gt; &lt;%= widget.load(\"app_market_dialog\") %&gt; &lt;!-- E 卡券相关弹框 --&gt; &lt;/div&gt; widget 一般存在可复用性。但如何控制细粒度呢？分得越细代码就越简洁，但工作量和维护难度可能会上升，因此需要权衡你当时的情况。 CSS 命名命名空间由于一个项目中，一个模块由某一个人负责，但模块之间的 widget 存在或未来存在可复用的可能（而且开发可能会为你的页面添加已有的组件，如页面会嵌在某 APP 内，该 APP 已有现成的一些提示框）。因此，需要命名空间将其它们进行区分以防止冲突。由于 CSS 不存在命名空间，因此只能通过类似 BEM 的方式（具体根据团队的规范），如：app_market_header、app_market_list_item。app_market 是模块（即某个活动）的标识，在该项目下，它是唯一的。 另外，还有一点：类名是否要按照 html 层级关系层层添加呢？如：123div.app_market_header div.app_market_header_icon div.app_market_header_** 对于 app_market_header_icon，尽管在 header 中，但 icon 并不只属于 header，而属于整个模块（活动），那么我们就可以改为 app_market_icon。 命名存在的问题老司机 Code review 后，讲了以下内容：反面教材：123456789&lt;div class=\"app_market_answer\"&gt; &lt;div class=\"app_market_secheader\"&gt;&lt;/div&gt; &lt;div class=\"app_market_answer_list\"&gt; &lt;div class=\"app_market_answer_item\"&gt; &lt;div class=\"app_market_answer_item_top\"&gt;&lt;/div&gt; &lt;div class=\"app_market_answer_item_middle\"&gt;&lt;/div&gt; &lt;a href=\"javascript:;\" class=\"app_market_answer_item_bottom\"&gt;去围观&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 存在的问题是：嵌套层级越深，类名就越长。 较好的解决方案：123456789&lt;div class=\"app_market_answer\"&gt; &lt;div class=\"app_market_secheader\"&gt;&lt;/div&gt; &lt;div class=\"app_market_answer_list\"&gt; &lt;div class=\"app_market_answer_item\"&gt; &lt;div class=\"app_market_answer_itop\"&gt;&lt;/div&gt;*** &lt;div class=\"app_market_answer_imid\"&gt;&lt;/div&gt;*** &lt;a href=\"javascript:;\" class=\"app_market_answer_ibtm\"&gt;去围观&lt;/a&gt;*** &lt;/div&gt;&lt;/div&gt; 这是基于『姓名』原理进行优化的，举例：app_market_answer_item 是姓名（库日天），那么它的子元素只需继承它的『姓』（库姆斯） app_market_answer_itop，而不是它的姓名（库日天姆斯） app_market_answer_item_top。每当类名达到三到四个单词长时，就要考虑简化名字。 进一步优化，app_market 可以看成是『复姓』，有时为了书写便利，可以以两个单词的首字母结合形成一个新的『新姓』- 『am』。当然，追求便利的副作用是牺牲了代码的可读性。如果你负责的项目或页面没有太大的二次维护或者交叉维护的可能性，推荐做此简化。 BTW：此简化后的『姓』可以在代码中稍加注释说明，如下代码所示：12345678910&lt;!-- am = app_market --&gt;&lt;div class=\"am_answer\"&gt; &lt;div class=\"am_secheader\"&gt;&lt;/div&gt; &lt;div class=\"am_answer_list\"&gt; &lt;div class=\"am_answer_item\"&gt; &lt;div class=\"am_answer_itop\"&gt;&lt;/div&gt; &lt;div class=\"am_answer_imid\"&gt;&lt;/div&gt; &lt;a href=\"javascript:;\" class=\"am_answer_ibtm\"&gt;去围观&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 针对类名书写样式123&lt;div&gt; &lt;a href=\"javascript:;\"&gt;...&lt;/a&gt;&lt;/div&gt; 至少加一个类名，任何时候都尽量要『针对类名书写样式，而不是针对元素书写样式』，除非你能预判元素是末级元素。因此对于以下 CSS：123.app_market_coupons &gt; div &#123; ...&#125; 可优化成：123.app_market_coupons &gt; .xxx &#123; ...&#125; 技术涉及REM移动端采用 rem 布局方式。通过动态修改 html 的 font-size 实现自适应。 实现方式REM 布局有两种实现方式：CSS 媒介查询和 JavaScript 动态修改。由于 JavaScript 更为灵活，因此现在更多地采用此方式。 JavaScript凹凸的实现方式是：在 head 标签末加入以下代码123456789101112131415161718192021222324252627282930313233343536&lt;script type=\"text/javascript\"&gt; !function()&#123; var maxWidth=750; document.write('&lt;style id=\"o2HtmlFontSize\"&gt;&lt;/style&gt;'); var o2_resize=function()&#123; var cw,ch; if(document&amp;&amp;document.documentElement)&#123; cw=document.documentElement.clientWidth,ch=document.documentElement.clientHeight; &#125; if(!cw||!ch)&#123; if(window.localStorage[\"o2-cw\"]&amp;&amp;window.localStorage[\"o2-ch\"])&#123; cw=parseInt(window.localStorage[\"o2-cw\"]),ch=parseInt(window.localStorage[\"o2-ch\"]); &#125;else&#123; chk_cw();//定时检查 return ;//出错了 &#125; &#125; var zoom=maxWidth&amp;&amp;maxWidth&lt;cw?maxWidth/375:cw/375,zoomY=ch/603;//由ip6 weChat window.localStorage[\"o2-cw\"]=cw,window.localStorage[\"o2-ch\"]=ch; //zoom=Math.min(zoom,zoomY);//保证ip6 wechat的显示比率 window.zoom=window.o2Zoom=zoom; document.getElementById(\"o2HtmlFontSize\").innerHTML='html&#123;font-size:'+(zoom*20)+'px;&#125;.o2-zoom,.zoom&#123;zoom:'+(zoom/2)+';&#125;.o2-scale&#123;-webkit-transform: scale('+zoom/2+'); transform: scale('+zoom/2+');&#125; .sq_sns_pic_item,.sq_sns_picmod_erea_img&#123;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scale('+zoom/2+');transform: scale('+zoom/2+');&#125;'; &#125;, siv, chk_cw=function()&#123; if(siv)return ;//已经存在 siv=setInterval(function()&#123; //定时检查 document&amp;&amp;document.documentElement&amp;&amp;document.documentElement.clientWidth&amp;&amp;document.documentElement.clientHeight&amp;&amp;(o2_resize(),clearInterval(siv),siv=undefined); &#125;,100); &#125;; o2_resize();//立即初始化 window.addEventListener(\"resize\",o2_resize); &#125;(); &lt;/script&gt; 从以上代码可得出以下信息： 以 iPhone 6 为基准，iPhone 6 的缩放比 zoom 为 1 由于只针对移动端，因此最大宽度为768（恰好等于 iPad 的竖屏宽度） 通过 document.documentElement.clientWidth 获取视口宽度 resize 事件主要考虑横竖屏切换和你在PC上调试时🙃 zoom 系数是 20。系数决定了在宽度 375 的 iPhone6 下，1 rem 的值是多少 px（20px）。当然如果想过渡到 vw，可以将 zoom 系数设置为 3.75，那么 100rem 就是 375px 了 为什么要用有人说 rem 布局是 vw 和 vh 的替换方案，当 vw 和 vh 成熟时，两者可能会各司其职吧。 vw 的兼容性：在安卓 4.3 及以下是不支持的。 哪些地方要用由于 rem 布局是相对于视口宽度，因此任何需要根据屏幕大小进行变化的元素（width、height、position 等）都可以用 rem 单位。 但 rem 也有它的缺点——不精细（在下一节阐述），其实这涉及到了浏览器渲染引擎的处理。因此，对于需要精细处理的地方（如通过 CSS 实现的 icon），可以用 px 等绝对单位，然后再通过 transform: scale() 方法等比缩放。 字体那 font-size 是否也要用 rem 单位呢？ 这也是我曾经纠结的地方。如果不等比缩放，对不起设计师，而且对于小屏幕，一些元素内的字体会换行或溢出。当然这可以通过 CSS3 媒介查询解决这种状况。 字体不采用 rem 的好处是：在大屏手机下，能显示更多字体。 看到 网易新闻 和 聚划算 的字体大小都采用 rem 单位，我就不纠结了。当然，也有其它网站是采用绝对单位的，两者没有绝对的对与错，取决于你的实际情况。 缺点小数点（不精细，有间隙）由于 rem 布局是基于某一设备实现的（目前一般采用 iPhone6），对于 375 倍数宽的设备无疑会拥有最佳的显示效果。而对于非 375 倍数宽的设备，zoom 就可能是拥有除不尽的小数，根元素的字体大小也相应会有小数。而浏览器对小数的处理方式不一致，导致该居中的地方没完全居中，但你又不能为此设置特定样式（如 margin-top: *px;），因为浏览器多如牛毛，这个浏览器微调居中了，而原本居中的浏览器变得不居中了。 对于图标 icon，rem 的不精细导致通过多个元素（伪元素）组合而成的 icon 会形成错位/偏差。因此，在这种情况下，需要权衡是否需要使用 CSS 实现了。 SASSSASS 无疑增强了原本声明式的 CSS，为 CSS 注入了可编程等能力。在这次项目，算是我第一次使用 SASS，由于构建工具和基础库的完善，只需通过查看/模仿已有项目的 SASS 用法，就能快速上手。后续还是要系统地学习，以更合理地使用 SASS。 使用 SASS 的最大问题是：层级嵌套过深，这也是对 SASS 理解不深入的原因。可以关注一下转译后的 CSS。 兼容性这次项目的 APP 采用手机自带浏览器内核，而这些浏览器内核依赖于系统版本等因素。另外，国产机也会对这些内核进行定制和修改。特别是华为、OPPO。 下面列出我所遇到的兼容性问题（不列具体机型，因为这些兼容性处理终会过时，不必死记硬背，遇到了能解决就好（要求基础扎实））： flexbox：在构建工具处理下（实现了新旧语法）可以大胆用，但个别设备不支持 flex-wrap: wrap。因此对于想使用 flex-wrap 实现自动分行的情况，建议使用其他实现。如果个数固定（如 N 行，每行 M 个），则可使用 N 个 flexbox（这样就可以使用 flexbox 的特性了）。flexbox 的其他属性也有支持不好的情况，可以通过显式声明 display、overflow、width、height 等方法解决。 background-size：需要单独写，否则在 安卓 4.3 及以下，IOS 6.1及以下不兼容。 渐变：线性渐变大胆使用，径向渐变有兼容性问题。但是不建议对整体背景使用，会有性能问题（可简单地通过 1px 高的图片替代，注意，不要 background-size: 100% auto; 应该采用 background-size: 100% 1px; 因为有些浏览器（视口宽度较小）会忽略小数点【auto = img.Height * (screen.Width/img.Width)】，导致图片未显示）。另外，需要注意的是：透明的色标在iOS 默认是黑色的，即 transparent 等于 rgba(0,0,0,0)。因此即使是完全透明的色标，也要指定颜色。否则后果如下： classlist.remove(String[, String])，传递多个参数时，会有不兼容的情况。建议每次写一个。add (String[, String])同理。 根节点 html font-size 渲染错误：在华为、魅族的某设备上（手Q），会出现一个非常奇葩的渲染 Bug，同一个网页，“扫一扫”打开 html 的 font-size 正常，直接点击链接会出现渲染出来的 html font-size 会比设置得值大（如：设置25.8，渲染出来是 29），因此导致整体变大，且布局错乱。我的方法是：为 html font-size 重新设置大小：渲染字体大小 - (渲染与正常差值) 1234567891011function getStyle(ele, style) &#123; return document.defaultView.getComputedStyle(ele, null)[style]&#125;;(function fixFontSize() &#123; var target = window.o2Zoom * 20 var cur = parseInt(getStyle(document.documentElement, \"fontSize\")) while(cur - target &gt;= 1) &#123; document.documentElement.style[\"fontSize\"] = target - (cur - target) + \"px\" cur = parseInt(getStyle(document.documentElement, \"fontSize\")) &#125; &#125;)(); 有网友提供这个方法 &lt;meta name=&quot;wap-font-scale&quot; content=&quot;no&quot;&gt;，经测试不可行。此方法是针对 UC 浏览器的。 上面主要列出了对使用有影响的兼容性问题，有些由于浏览器渲染引擎导致的问题（不影响使用），若无法通过 transform、z-index 等解决，也许只能通过 JavaScript 解决或进行取舍了。 其他一些知识点 图片占位元素：对于宽高比例固定的坑位（如商品列表项），通过将图片放置在占位元素中，可避免图片加载时引起的页面抖动和图片尺寸不一致而导致的页面布局错乱。代码实现： .img_placeholder { position: relative; height: 0; overflow: hidden; padding-top: placeholder 的高/宽%; // padding-top/bottom: 百分比; 是基于父元素的宽度 img { width: 100%; height: auto; position: absolute; left: 0; top: 0; } } 1px：在 retina 屏幕下，1 CSS像素是用 4 个物理像素表示，为了在该屏幕下显示更精细，通过为 ::after 应用以下代码（以上边框为例）： div { position: relative; &amp;::after { content: &apos;&apos;; position: absolute; z-index: 1; pointer-events: none; background: $borderColor; height: 1px;left: 0;right: 0;top: 0; @media only screen and (-webkit-min-device-pixel-ratio:2) { &amp;{ -webkit-transform: scaleY(0.5); -webkit-transform-origin: 50% 0%; } } } } 根据元素个数应用特定样式： /* one item */ li:first-child:nth-last-child(1) { width: 100%; } /* two items */ li:first-child:nth-last-child(2), li:first-child:nth-last-child(2) ~ li { width: 50%; } /* three items */ li:first-child:nth-last-child(3), li:first-child:nth-last-child(3) ~ li { width: 33.3333%; } /* four items */ li:first-child:nth-last-child(4), li:first-child:nth-last-child(4) ~ li { width: 25%; } 应用样例有：根据元素个数自适应标签样式。 而对于反方向标签，可先首先对整体 transform: scale(-1)，然后再对字体 transform: scale(-1) 恢复从左向右的方向。效果如下： 卡券：『带孔且背景是渐变的卡券』在复杂背景中的实现。由于背景是复杂的（非纯色），因此孔不能简单地通过覆盖（与背景同色）产生。这里可以应用径向渐变 background-image: radial-gradient(rem(189/2) 100%, circle, transparent 0, transparent 3px, #fa2c66 3px);，其中 3px 是孔的半径。另外，卡券的上下部分是线性渐变的，因此可以在上下部分分别通过伪类元素添加 background-image: linear-gradient(to top, #fa2e67 0, #fb5584 100%);，当然，要从离外上/下边界 3px 的地方开始。虽然这不能完美地从最边界开始，但效果还是可以的。但由于径向渐变的兼容性问题，我最终还是用图片替换了这种实现。🙄 多行文本的多行padding：让背景只出现在有文字的地方，可直接设置 display: inline;，但还会存在一个问题是：padding 只会出现在多行文本的首和尾，对于需要为每行文本的首尾都需要相同的 padding，可以参考这篇文章：《multi-line-padded-text》 。该文章提供了多种实现方式，根据具体情况选择一种即可。另外，对于每行的间距，可通过设置 line-height 和 padding-top/bottom 实现，其中 line-height 要大于（字体高度+padding-top/bottom）。 最小字体限制：PC上最小字体是 12px、移动端最小是 8px，当然可通过 transform:scale() 突破限制。 不止页面页面制作 基础：合理运用 CSS 的威力更好地完成对设计稿的重现目的。 沟通：由于分工较细，只负责页面制作的同学，需要与产品和设计沟通，以达到交给开发后更少修改的目的。如哪些地方可跳转、哪些地方最多显示几行文字、超出如何处理（直接隐藏/省略号等）、坑位中的图片摆放（顶部对齐/居中等）等等。 代码上的沟通：HTML 注释要写好、HTML 与 CSS 代码要规范（命名等）清晰。 思考由于工具的成熟，我不需要考虑构建工具的搭建。由于发布方式的成熟，页面制作和开发能更好地分离，页面制作者负责输出 HTML、CSS，开发负责 copy html 代码和引入 CSS 页面片。CSS 页面片由页面制作者更新发布，开发无需关心。这达到了互不干扰、多线程并行的效果。成熟的基础设施让我们免除了非代码相关的烦恼，但这也让我担心：假如有一天我脱离了这些基础设施，我该如何保持高效。 延伸：页面片是什么？CSS 页面片12&lt;!-- #include virtual=\"/folder/branch.shtml\" --&gt;&lt;link combofile=\"/folder/branch.shtml\" rel=\"stylesheet\" href=\"//website/folder/gb.min_1151b5b0.css,/folder/branch.min_925332fc.css\" /&gt; JS 页面片12&lt;!-- #include virtual=\"/folder/branch_js.shtml\" --&gt;&lt;script combofile=\"/folder/branch.shtml\" src=\"//website/path/branch.min_8971778a.js\"&gt;&lt;/script&gt; Combo Handler是Yahoo!开发的一个Apache模块，它实现了开发人员简单方便地通过URL来合并JavaScript和CSS文件，从而大大减少文件请求数。 http://www.cnblogs.com/zhengyun_ustc/archive/2012/07/18/combo.html 这就是我的第一次…🙈 学习很多，完！ 以上仅是我个人完成某项目页面制作的思考和总结，不小心暴露了团队下限。🌚","pubDate":"Tue, 08 Nov 2016 08:22:23 GMT","guid":"https://aotu.io/notes/2016/11/08/first-mobile-rebuild/","category":"项目总结"},{"title":"APNG 那些事","link":"https://aotu.io/notes/2016/11/07/apng/","description":"凹凸君： GIF 存活 29 年之久，依然大行其道的今天，有没有更合适的动画格式？ 回答： 或许，可以聊聊 APNG。 关于 APNGAPNG（Animated Portable Network Graphics）顾名思义是基于 PNG 格式扩展的一种动画格式，增加了对动画图像的支持，同时加入了 24 位图像和 8 位 Alpha 透明度的支持，这意味着动画将拥有更好的质量，其诞生的目的是为了替代老旧的 GIF 格式，但它目前并没有获得 PNG 组织官方的认可。 APNG 简史MNG 在 APNG 之前它还有一个老冤家叫 MNG（Multiple-image Network Graphics）即多图像网络图形，1996 年 6 月提出 PNF（Portable Network Frame）草案，同年8月更名为 MNG ，2001 年 1 月 31 日发布 MNG 规范 1.0 版本，MNG 是出自 PNG 开发组之手，但由于结构复杂的 MNG 程序库，使用过程会占用大量的资源，早期只有较少的浏览器支持，Chrome、IE、Opera、Safari 则从未支持过。 APNG 2004 年，由 Mozilla 公司两位 Mozilla 程序员 Stuart Parmenter 和 Vladimir Vukićević 共同设计出 APNG，他们希望 Mozilla 社区能使用它，但提案未能通过。 libpng程序库 2006 年，Google Summer of Code 活动中，加拿大圣力嘉学院的学生为 libpng 程序库加入了对 APNG 支持，此后开发者再次推荐给 Mozilla 社区，不过仍然遭到拒绝。 首次支持 2007 年 3 月 23 日，Mozilla 后知后觉，在 Mozilla Firefox 3.0 中 首次支持 APNG 格式。 标准化申请 2007 年 4 月 20 日，Mozilla 希望 APNG 能成为官方标准，因此 PNG 组织发起投票，最终以8：10的票数否决了 APNG 进了官方标准，因为 PNG 组织决心继续推广 MNG，但这不并影响 Mozilla 继续支持 APNG。 为什么 GIF 能存活29年之久？开头讲 APNG 时提到，APNG 的出现就是为了替代 GIF，诞生于 1987 年的 GIF 为什么能存活 29 年之久？ 主要有四个原因： 几乎所有的主流浏览器都支持 GIF 早期选择不多，GIF 几乎是唯一选择（GIF - 1987、JPEG - 1992、PNG - 1996、APNG - 2004、WebP - 2010） 实现起来简单，制作的工具多 采用 LZW 数据压缩算法，使得 GIF 体积小，在早期慢速的互联网易于传播 为什么要取代它？1、图片质量 GIF APNG 如果你使用的是非 Firefox、Safari 浏览器，那 APNG 格式的图片会向下兼容显示为静态图，你可以更换 Firefox、Safari 浏览器或者在 Chrome 浏览器安装 APNG Extension for Google Chrome 扩展来兼容，通过两者对比能总结出以下区别： GIF： 最多支持 8 位 256 色，色阶过渡糟糕，图片具有颗粒感 不支持 Alpha 透明通道，边缘有杂边 APNG： 支持 24 位真彩色图片 支持 8 位 Alpha 透明通道 向下兼容 PNG 2、图片体积 如果你使用的浏览器不支持WebP，下面对比的 WebP 格式的图片将无法显示。 GIF = 43 920 bytesAPNG = 34 210 bytesWebP = 41 064 bytesLossy WebP = 73 774 bytesGIF = 43 132 bytesAPNG = 30 823 bytesWebP = 55 968 bytesLossy WebP = 114 518 bytesGIF = 200 700 bytesAPNG = 168 411 bytesWebP = 424 752 bytesLossy WebP = 394 118 bytes 从几组 GIF、APNG、WebP 的对比中可以发现，无论在纯色的图片或是多彩的图片，大部分情况下 APNG 依旧能比 GIF、WebP 以及有损的 WebP 的体积小。 APNG 的组成APNG 是基于 PNG 格式扩展的，首先需要了解一个简单的 PNG 文件组成结构：PNG SignatureIHDRIDATIEND PNG 由 4 部分组成，首先以 PNG Signature（PNG签名块）开头，紧接着一个 IHDR（图像头部块），然后是一个或多个的 IDAT（图像数据块），最终以 IEND（图像结束块）结尾。 APNG 规范引入了三个新大块，分别是：acTL（动画控制块）、fcTL（帧控制块）、fdAT（帧数据块），下图是三个独立的 PNG 文件组成 APNG 的示意图。 acTL 块必须在第一个 IDAT 块之前，用于告诉解析器这是一个动画 PNG，包含动画帧总数和循环次数的信息 fcTL 块是每一帧都必须的，出现在 IDAT 或 fdAT 之前，包含顺序号、宽高、帧位置、延时等信息 fdAT 块与 IDAT 块有着相同的结构，除了 fcTL 中的顺序号 从图中可以发现第一帧与后面两帧不同，那是因为第一帧 APNG 文件存储的为一个正常的 PNG 数据块，对于不支持 APNG 的浏览器或软件，只会显示 APNG 文件的第一帧，忽略后面附加的动画块，这也是为什么 APNG 能向下兼容 PNG 的原因。 APNG 帧间优化假设使用一个 4 帧图片合成 APNG APNG 会通过算法计算帧之间的差异，只存储帧之前的差异，而不是存储全帧。 通过 TweakPNG 软件观察 IDAT 图像数据块和 fdAT 帧数据块的大小，可以明显的看出来存储全帧与差异帧的区别，使得 APNG 文件大小有显著的减少。 为什么没有普及？ 主要的原因是缺乏浏览器的支持，从 Can I use 查询可知 Firefox 从 3 到 49 版本自始自终支持着，Opera 早期只有三个版本支持过（10.1、11.5、12.1），后续版本则取消了对 APNG 的支持，而 Chrome、IE、Edge 则从未支持过 APNG，Chrome 和 Opera 都在推广自家的 WebP，而微软则一直是个不合群的家伙。 但是，重要的一点是 2014 年 9 月 17 号 Apple 向用户推送了 iOS 8，这意味着 Safari 8 新增了对 APNG 的支持，这能有效的推动 APNG 的发展，至少在移动端。 特性检测既然存在兼容问题，那就需要通过判断应用场景。 12345678910(function() &#123; \"use strict\"; var apngTest = new Image(), ctx = document.createElement(\"canvas\").getContext(\"2d\"); apngTest.onload = function () &#123; ctx.drawImage(apngTest, 0, 0); self.apng_supported = ctx.getImageData(0, 0, 1, 1).data[3] === 0; &#125;; apngTest.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACGFjVEwAAAABAAAAAcMq2TYAAAANSURBVAiZY2BgYPgPAAEEAQB9ssjfAAAAGmZjVEwAAAAAAAAAAQAAAAEAAAAAAAAAAAD6A+gBAbNU+2sAAAARZmRBVAAAAAEImWNgYGBgAAAABQAB6MzFdgAAAABJRU5ErkJggg==\";&#125;()); 方法与 WebP 检测相似，同样是加载一张 1x1 像素大小的 Base64 编码图片，不同在于 WebP 加载完成后是判断图片宽高是否大于 1，而 APNG 则是将其绘制到画布中，通过 getImageData() 方法去获取该图片的像素数据，主要是获取 data[3] 的 Alpha 透明通道（值的范围：0 - 255），当返回 0（0代表透明的）时则表示支持 APNG，返回 255（255 代表完全可见的）则表示不支持 APNG。 APNG to Canvas当然，目前也有用于兼容的库：apng-canvas 使用该库需要以下条件支持： Canvas Typed Arrays Blob URLs requestAnimationFrame 1&lt;img src=\"example.png\" class=\"apng-image\"&gt; 123456APNG.ifNeeded().then(function() &#123; var images = document.querySelectorAll(\".apng-image\"); for (var i = 0; i &lt; images.length; i++) &#123; APNG.animateImage(images[i]); &#125;&#125;); DEMO 戳这里 制作工具在了解 APNG 后，是不是心痒痒想制作 APNG 呢？在制作工具方面，APNG 已经不像早期那样工具匮乏了，APNG Software 网站上有大量的制作工具，有客户端版本（大部分只支持 Widnows）也有命令行版本，可以非常轻松的制作 APNG，比如下面这款软件。 Windows客户端 - APNG Assembler Mac客户端 - APNGb 功能说明： Playback Settings 可设置循环的次数，0 表示无限循环，可跳过第一帧 Delays - All Frames 可设置所有帧播放时所停留的时间 Compression Settings 可设置压缩参数，有三种压缩方式（zlib、7zip、Zopfli）以及颜色类型和调色板优化 Delays - Selected Frames 可设置选中帧播放时所停留的时间 这里演示图分别是 Windows 版本和 Mac 版本，功能基本一致，将序列帧图片拖拽到指定位置，设置一些基本的参数即可生成 APNG 图，Mac 版本比 Windows 版本多出一个将 APNG 图片 Disassembly（分解）功能，可分解为多个 PNG 图片。 下载地址戳这里 投票呼吁在最后，如果你认为 APNG 是值得被支持、被推广的，请为它投上一票和点 Stars（需科学上网）。 APNG support in Chrome : issue 1171、issue 437662 APNG support in IE : Votes 感谢你的阅读。 参考资料Animated PNG demosGIF vs APNG vs WebPInter-frame Optimization in APNGdavidmz/apng-canvas - GithubGIF - WikipediaAPNG - WikipediaAPNG SpecificationCan I use - APNGPortable Network Graphics - WikipediaMultiple-image Network Graphics - WikipediaAPNG Software","pubDate":"Mon, 07 Nov 2016 09:48:31 GMT","guid":"https://aotu.io/notes/2016/11/07/apng/","category":"性能优化"},{"title":"AdobeMax 2016回顾","link":"https://aotu.io/notes/2016/11/02/AdobeMax2016/","description":"今年的 AdobeMax 大会于美国时间 10.31-11.04 在加州第二大城市圣地亚哥举办。AdobeMax大会内容包括发布了Adobe Creative Cloud旗下一系列软件的新版本、实验性项目展示、从业人员交流等。今年的大会有什么有(hei)趣(ke)的(ji)发布了呢？让小编带你去逛一圈看看吧。 1. Photoshop CC 2017（简称PS2017）首先介绍前端er每天都要接触到 Photoshop ，顺便赞一下 mac 版的安装速度，不到2min就搞定。PS2017 做了如下更新： 扁平化 UI 更好的程序内搜索 无缝衔接 Adobe Experience Design 更好整合 Adobe 资源模板(Adobe stock)、云同步等等 更强大的抠图和液化功能 Apple Color Emoji，即支持了 emoji 编辑 ………… 大部分都和前端开发都不太沾边，小编很艰难的发现了几个沾边的： 右键图层新菜单项“拷贝 SVG”，即可直接拷贝图层的 svg 代码 文件-导出-导出为（或右键图层“导出为”）面板选择保存 png 的时候可以直接勾选保存为 png8 格式 顺便说一下 mac 下的 PS2017 的窗口用 sizeup 的快捷键调整也不会像之前那样不正确了，半屏、全屏切换正常。 2. Adobe Experience Design CC（简称XD）今年早些时候发布了预览版，仅支持 mac 。大会上新发布了新的 Beta 版，并且支持了 windows 。 XD 是一款矢量化图形设计、web &amp; 移动 app 原型制作软件——嗯，据说就是死磕 Sketch 。特点是多种内置UI组件、各种酷炫效果、手机端实时预览效果等等。 3. Character Animator（简称Ch）Ch(Beta) 这是 Adobe 的一个新产品，可通过电脑摄像头来追踪用户的动作和面部表情，并将其实时应用在虚拟2D动画角色上，软件会自动完成动作之间的形变动画计算，无需软件使用者操心。大会上介绍这个软件的时候居然有一段是直播辛普森动画的，非常好玩。 小编并且亲自安装了 Ch 并体验了一遍内置的样例（根本停不下来），发现这个软件真的非常神奇。没了解过的同学强烈介意看一下这个视频了解一下其用途：点此观看 这个软件的大概工作流程是这样的： Ch里新建 Puppet（new Puppet in Photoshop）——打开 PS 编辑角色(默认打开一个结构化图层的角色样例)——编辑后保存——返回 Ch 把 Puppet 拖入场景舞台——点击右上角的“set rest post”——点击场景面板的红色“录制”按钮，然后就到你尽情表演的时候啦…… 以下是小编用样例录的一段“表演”： 所以以后直播网站里是不是要加上一个“二次元直播”频道？ 4. Adobe SenseiAdobe推出的智能云计算服务，Sensei并非一款单独的软件产品，而是一个可以应用于Adobe旗下各款产品的底层人工智能工具（如 Photoshop、Illustrator）。 该服务具体的内容是让软件明白某张照片、某张照片的一部分、某段视频以及某段文本描述的真实含义，帮助人们把一些固定、重复性的操作变得自动化和简单化。有了海量的分析数据，会让用户处理一些图像、视频、音频变得非常简单和智能，以前需要调整一堆参数才能实现的效果以后只需要几个简单的鼠标操作。下面将要提到的 ConceptCanvas、SkeyReplace 技术就是一个具体的应用方向。 其他实验性项目以下介绍的技术还没正式面向用户，Adobe 每年都会在大会上推出一些实验性技术，相当一部分在接下来的几年里会推出面向大众的产品，比如XD就是2015年的实验性项目 Project Comet。 1. ConceptCanvas先上一张图： 这是大会现场的一个截图，左边是PS界面，右边是一列是搜索结果。 可以看出这个搜索技术利用简单的图像关键字、构图、颜色、物体位置等信息进行素材搜索，素材来源由于版权原因估计短时间内只支持Adobe Stock。感觉这种搜索方式比常见的搜索引擎以图搜图更加容易被设计师接受，因为实在太简单直观了，有点佩服Adobe工程师的脑洞。 要更直观的感受可以看一下这个演示视频：观看地址 很希望搜索引擎搜图也可以加入类似的技术，在海量图片的网络找图我们是不是可以更便捷、发挥更多想象力？ 2. Project VoCo这是一个神奇的声音编辑软件，可以根据你录制好的一段音频（长度大约20分钟），系统会学习并模仿你的语气。然后输入你想说的文字，就可以根据文字内容输出一段你的声音的音频，听上去就像你真的说过这段话。 问题来了，以后声音造假和图像造假一样成本真的很低？你不想在朋友圈晒一段你和周杰伦的通话录音？ 这是VoCo现场演示的视频，点此观看 3. InterVector从照片提取矢量数据的一种技术，如提取轮廓并调整、删除等，这是Illustrator目前正在开发的一部分功能。 4. SkyReplace即照片天空智能替换技术，以后婚纱照的真的一点也不怕坏天气？ 以上就是AdobeMax大会要介绍的主要内容，还有一些设计专业性很强的技术如Stylit、ColorChameleon、Wetbrush等，有兴趣的可以去下面的参考资料看看。 参考资料 https://helpx.adobe.com/photoshop/using/whats-new.html https://twitter.com/adobemax http://weibo.com/adobechina https://tech.recruit-mp.co.jp/event/post-10848/ http://web.cndesign.com/news/detail_698.html","pubDate":"Wed, 02 Nov 2016 13:22:23 GMT","guid":"https://aotu.io/notes/2016/11/02/AdobeMax2016/","category":"体验报告"},{"title":"border-image 的正确用法","link":"https://aotu.io/notes/2016/11/02/border-image/","description":"border-image 的正解用法border-image 边框图片，顾名思义: 指定边框使用的图片。尽管经常使用 border-image(-webkit-border-image)，但我们真的了解它的吗？ 本文分两部分来介绍 border-image： border-image 简史 border-image 用法 1. border-image 简史CSS3 border 最开始是做为一个独立模块(CSS3 module: Border)被维护，后来(2005.2.16) W3C工作组将 border 和 background 两个模块合并作为一个新模块：CSS3 Backgrounds and Borders Module，08年又将其改名为 CSS Backgrounds and Borders Module Level 3。以下是具体过程： CSS3 module: BorderW3C Working Draft 7 November 2002 CSS3 Backgrounds and Borders ModuleW3C Working Draft 16 February 2005 CSS Backgrounds and Borders Module Level 3W3C Working Draft 10 September 2008W3C Working Draft 15 October 2009W3C Candidate Recommendation 17 December 2009W3C Working Draft 12 June 2010W3C Candidate Recommendation 15 February 2011W3C Working Draft 14 February 2012W3C Candidate Recommendation 17 April 2012W3C Candidate Recommendation 24 July 2012W3C Last Call Working Draft 4 February 2014W3C Candidate Recommendation 9 September 2014 在 CSS3 border 的第一个工作草案(WD)『W3C Working Draft 7 November 2002』 定义了 border-image 的用法，经过漫长的十几年修订，border-image 经历了三次重要的演变： 1.1 草创阶段 The border-image properties allow the author to assign images to borders. There are four groups of border image properties:Specifying border imagesThese properties are used to specify the URI of the border image.Fitting border imagesThese properties are used to specify how the image(s) are fitted in the border area.Transforming border imagesThese properties are used to make the images of a side or a corner to be reflected or rotated versions of another.The border image properties override the border style properties.—— 摘录自：『W3C Working Draft 7 November 2002 #the-border-image』。 此时的 border-image 由3组属性成，分别是： border-image/border-corner-image border-fit/border-corner-fit border-transform/border-corner-transform (ps: W3C 文档里提到有四组属性。不过笔者只找到上述三组) 1. border-image/border-corner-imageborder-image 指定四边的图像，border-corner-image 指定四个角的图像，注意这里分开指定四条边和四个角的图片即需要使用8个图像。如下： 另外，每条边都可以指定三张图片： 2. border-fit/border-corner-fit指定 border-image/border-corner-image 的平铺方式。 3.border-transform/border-corner-transform指定 border-image/border-corner-image 的变换方式。 具体可以参见：https://www.w3.org/TR/2002/WD-css3-border-20021107/#the-border-image 这个古老的版本对 bordr-image 做了全面的定义，甚至比当前(2016.11.1)的标准还要周到详细，但是这个版本过于笨重，很快被 W3C 的新标准替代。 1.2 发展阶段『W3C Working Draft 16 February 2005』对上个版本做了极大的精简工作，并重新定义了一个简洁的 border-image ，语法如下： 1border-image: none | &lt;uri&gt; [&lt;number&gt; | &lt;percentage&gt;]&#123;4&#125; [ / &lt;border-width&gt;&#123;1,4&#125; ]? [stretch | repeat | round]&#123;0,2&#125; The four numbers or percentages immediately following the specify which part of that image is used for which part of the border. They divide the image into nine parts: four corners, four edges and a middle part. The middle part is used as an extra background image.—— 摘录自：https://www.w3.org/TR/2005/WD-css3-background-20050216/#the-border-image 这个版本提出了九宫格的概念(border-image的精髓)并提供了简洁的语法。 Chrome/Safari 私有的 -webkit-border-image 实现了这个版本的语法，并将其发扬光大。至今(2016.11.1)国内不少介绍 border-image 技术文章都是在介绍这个版本。 1.3 成熟阶段修订版 『W3C Working Draft 15 October 2009』在上个版本的基础上将 border-image 分拆成 border-image- 家族，同时加入一个新的成员 border-image-outset。border-image- 成员如下： border-image-source border-image-slice border-image-width border-image-outset border-image-repeat border-image 成为上述五个属性的简写，语法也从此稳定下来，俨然已是一个正式的 W3C 标准(REC)。 2. border-image 的正确用法 Authors can specify an image to be used in place of the border styles. In this case, the border’s design is taken from the sides and corners of an image specified with ‘border-image-source’, whose pieces may be sliced, scaled and stretched in various ways to fit the size of the border image area. The border-image properties do not affect layout: layout of the box, its content, and surrounding content is based on the ‘border-width’ and ‘border-style’ properties only.—— 摘录自： https://www.w3.org/TR/css3-background/#border-images border-image 通过指定一张图片来取替 border-style 定义的样式，但 border-image 生效的前提是： border-style 和 border-width 同时为有效值(即 border-style 不为 none，border-width 不为 0)。 本章按 『W3C Candidate Recommendation 9 September 2014』规范来介绍 border-image 的用法。 2.1 border-image-source语法：1border-image: none | &lt;image&gt; 指定边框图片的地址。 none 表示border-image不做任何效果，边框使用 border-style 指定的样式。 2.2 bordre-image-slice语法：1bordre-image-slice [&lt;number&gt; | &lt;percentage&gt;]&#123;1,4&#125; &amp;&amp; fill? border-image-slice 从名字上看就很好理解：边框图像切片。指定4个值(4条分割线：top, right, bottom, left)将 border-image-source 分割成9宫格，如下： 四条分割线的值 border-image-slice 四条线的值类型为：number | percentage。 number 不带单位的数值。1 代表 1个图片像素。percentage 百分比。 错误的写法：1border-image-slice: 27px 27px 27px 27px; 正确的写法：1border-image-slice: 27 27 27 27; 关键字：fill Specifies an image to use in place of the rendering specified by the ‘border-style’ properties and, if given the ‘fill’ keyword in ‘border-image-slice’, as an additional image backdrop for the element. 关键字fill的作用是：将border-image-source九宫格中间那一块切片作为DOM节点的背景。 素材图片box.png: CSS 代码：123456.box &#123; width: 27px; height:27px; border: 27px solid; border-image: url(box.png) 27 27 27 27 fill repeat stretch;//fil？&#125; 测试结果如下： 线上DEMO： 2.3 border-image-width语法： 1border-image-width: [ &lt;length&gt; | &lt;percentage&gt; | &lt;number&gt; | auto ]&#123;1,4&#125; border-image-width 字面意思是边框图片宽度，作用是将 DOM 节点分割成九宫格。 假设 border-image-slice 分割 border-image-source 的九宫格为A， border-image-width 分割 DOM 的九宫格为 B，A 与 B 的每个格子存在一一对应关系，具体如下： border-image-width 参数的四种类型: length 带 px, em, in … 单位的尺寸值percentage 百分比number 不带单位的数字；它表示 border-width 的倍数auto 使用 auto， border-image-width 将会使用 border-image-slice 的值 border-image-width 的参数不能为负值border-image-width的缺省值是 number 类型：1 2.3.1 border image areaborder image area 是成熟阶段被引入用于解释 border-image-width 和 border-imaeg-out 的概念。 The border image is drawn inside an area called the border image area. This is an area whose boundaries by default correspond to the border box—— 摘录自: https://www.w3.org/TR/css3-background/#border-image-width 用于绘画 border image 的区域叫 border image area，它默认与边框盒子(border box)完全重合。简单地说，border image area 就是 border-image-width 分割出来的九宫格。 2.3.2 border-box 与 border image area 的关系上面有提到，border image area 默认与 border-box 是重合关系。如果把标准后退到发展阶段： 1border-image: none | &lt;uri&gt; [&lt;number&gt; | &lt;percentage&gt;]&#123;4&#125; [ / &lt;border-width&gt;&#123;1,4&#125; ]? [stretch | repeat | round]&#123;0,2&#125; 在发展阶段，DOM节点由 border-width 分割为九宫格，这个时期的 border-box 就是 border image area。 到了成熟阶段（即本章介绍的版本），border-box 与 border image area 是默认重合的两个空间，border-box 只负责盒子模型上的事务，border image area 则专注于边框图像空间分割。 2.3.3 border-width 可以分割 border image area?在实际使用过程中，笔者发现 border-width 也可以分割 border image area。如下： 测试CSS代码：123456789.box &#123; margin: 0 auto; width: 27px; height: 27px; border: 27px solid rgba(242,181,78,.3); border-image-source: url(http://7xv39r.com1.z0.glb.clouddn.com/box.png); border-image-slice: 27 27 27 27 fill; border-image-repeat: stretch stretch;&#125; 截图如下： 如果单从上述测试结果而言，border-width 可以分割 border image area 是正确。不过，这个结论有一个前提：border-image-border 与 border-image-outset 同时缺省。如果将 CSS 代码修为： 12345678910.box &#123; margin: 0 auto; width: 27px; height: 27px; border: 27px solid rgba(242,181,78,.3); border-image-source: url(http://7xv39r.com1.z0.glb.clouddn.com/box.png); border-image-slice: 27 27 27 27 fill; border-image-outset: 10px; border-image-repeat: stretch stretch;&#125; 截图如下： 设置了 border-image-outset 后 border-width 的分割 border image area 的假像就被揭穿了！！border-width 分割 border image area 的假象源自 border-image-width 的缺省值1，数值1表示 border-image-width 是 1x border-width，大白话就是border-image-width 的默认值是border-width。 尽管在最新的CSS3标准中 “border-width 分割 border image area” 只是个假像，但当前(2016.11.1)阶段，为了更多浏览器兼容建议 border-width 与 border-image-width 保持一致，即使用 border-width 暂代 border-image-width。 2.4 border-image-outset语法：1border-image-outset: [ &lt;length&gt; | &lt;number&gt; ]&#123;1,4&#125; border-image-outset 字面意思是边框图片开端。作用是重新指定 border image area 的边界。 The values specify the amount by which the border image area extends beyond the border box. If it has four values, they set the outsets on the top, right, bottom and left sides in that order. If the left is missing, it is the same as the right; if the bottom is missing, it is the same as the top; if the right is missing, it is the same as the top.—— 摘录自：https://www.w3.org/TR/css3-background/#border-image-outset 通过指定 border-image-outset 的值，可以把 border image area 的区域延伸到 border-box 之外。如下： 123456789101112.box &#123; margin: 0 auto; width: 81px; height: 81px; border: 27px solid rgba(0,0,0,.1); border-image-source: url(//misc.aotu.io/leeenx/border-image/box.png); border-image-slice: 27 27 27 27; border-image-repeat: repeat;&#125;.outset &#123; border-image-outset: 27px;&#125; 对比： 二维码: border-image-outset 与 border-image-width 参数的意义是一样的。 border-image-outset 的值不能为负值 2.5 border-image-repeat语法：1border-image-repeat: [ stretch | repeat | round | space ]&#123;1,2&#125; border-image-repeat 字面意义是 边框图片平铺。作用是指定 border-image 的平铺方式。语法上最多可接收两个参数，第一个参数指定水平方向边框的平铺方式，第二个参数指定垂直方向边框的平铺方式，九宫格的中间区域受这两参数的共同影响，如下： 目前只能四值可供选择：stretch, repeat, round, space。其中，stretch 是默认值，space 目前chrome浏览器按 repeat 来渲染。这四个参数的效果如下： repeat 与 round 的区别：round 除了能平铺外还能通过伸缩使背景完整显示。round 与 space 的区别：虽然都使背景完整显示，但是 space 在小方块之间有一定的空隙。 二维码: 简写：border-image语法： 1border-image: &lt;‘border-image-source’&gt; || &lt;‘border-image-slice’&gt; [ / &lt;‘border-image-width’&gt; | / &lt;‘border-image-width’&gt;? / &lt;‘border-image-outset’&gt; ]? || &lt;‘border-image-repeat’&gt; 简写其实没什么好说的，不过由于 border-image-slice、border-image-width 与 border-image-outset 这三者的参数相似，所以有必要说一下，这三个参数在简写里有两个注意点: 一、 border-image-outset 参数一定要在 border-image-width 之后，假设border-image-width缺省，仍然需要在原来 border-image-width 写上 /，如下： 正确的写法：1border-image: url(http://7xv39r.com1.z0.glb.clouddn.com/box.png) 27 27 27 27 / / 10px; 错误的写法：1border-image: url(http://7xv39r.com1.z0.glb.clouddn.com/box.png) 27 27 27 27 / 10px;//这样写 10px会被当作 border-width 二、 如果有 border-image-width/ border-image-outset 属性值，border-image-slice必须指定数值，否则不合语法，如下： 正确的写法:1border-image: url(http://7xv39r.com1.z0.glb.clouddn.com/box.png) 27 27 27 27 / 10px / 10px; 错误的写法：1border-image: url(http://7xv39r.com1.z0.glb.clouddn.com/box.png) / 10px / 10px; 后记实践过程中遇到BUG： safari浏览器下，border-color不能使用 transparent 与 rgba(x,x,x, 0)。否则，border-image 会失效。 补记于：2016.12.26 参考资料： W3C Working Draft 7 November 2002 W3C Working Draft 16 February 2005 W3C Candidate Recommendation 9 September 2014 css3：border-image边框图像详解 CSS3 border-image详解、应用及jQuery插件","pubDate":"Wed, 02 Nov 2016 13:22:23 GMT","guid":"https://aotu.io/notes/2016/11/02/border-image/","category":"Web开发"},{"title":"Javascript 中的装饰器","link":"https://aotu.io/notes/2016/10/24/decorator/","description":"前言在 ES6 中增加了对类对象的相关定义和操作（比如 class 和 extends ），这就使得我们在多个不同类之间共享或者扩展一些方法或者行为的时候，变得并不是那么优雅。这个时候，我们就需要一种更优雅的方法来帮助我们完成这些事情。","pubDate":"Mon, 24 Oct 2016 12:49:11 GMT","guid":"https://aotu.io/notes/2016/10/24/decorator/","category":"Web开发"},{"title":"CSS3 Mask 安利报告","link":"https://aotu.io/notes/2016/10/19/css3-mask/","description":"朋友，你听说过 CSS3 Mask 这个属性吗？没听说过？不是很了解？没关系，听我娓娓道来。","pubDate":"Wed, 19 Oct 2016 10:48:16 GMT","guid":"https://aotu.io/notes/2016/10/19/css3-mask/","category":"Web开发"},{"title":"Vue2.0 新手完全填坑攻略——从环境搭建到展示豆瓣的电影列表","link":"https://aotu.io/notes/2016/10/13/vue2/","description":"Jinkey原创感谢 showonne、yubang 技术指导Demo 地址: http://demo.jinkey.io/vue2源码:https://github.com/Jinkeycode/vue2-example 什么是 VueVue 是一个前端框架，特点是 数据绑定 比如你改变一个输入框 Input 标签的值，会自动同步更新到页面上其他绑定该输入框的组件的值￼ 组件化 页面上小到一个按钮都可以是一个单独的文件.vue，这些小组件直接可以像乐高积木一样通过互相引用而组装起来 ￼ Vue2.0 推荐开发环境￼ Homebrew 1.0.6(Mac)、Node.js 6.7.0、npm 3.10.3、webpack 1.13.2、vue-cli 2.4.0、Atom 1.10.2 安装环境打开终端运行以下命令 安装brew1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装 nodejs brew install nodejs 用 npm install npm@3.10.3 更新 npm 版本报错: (node:42) fs: re-evaluating native module sources is not supported. 解决办法: 在官网下载6.70的安装包再安装一次(刚刚相当于帮你配置好环境变量，现在再安装一次升级到最新的 npm) 好像以前官网的安装包不会自动配置环境变量的，由于我电脑上之前安装过 nodejs 所以环境变量已经配置好了，不知道现在的安装包会不会自动配置环境变量。 Windows 下直接下载安装包即可 获取nodejs模块安装目录访问权限1sudo chmod -R 777 /usr/local/lib/node_modules/ 安装淘宝镜像 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装webpack cnpm install webpack -g 安装vue脚手架 npm install vue-cli -g 在硬盘上找一个文件夹放工程用的，在终端中进入该目录Mac cd 目录路径 根据模板创建项目 vue init webpack-simple 工程名字&lt;工程名字不能用中文&gt; 或者创建 vue1.0 的项目 vue init webpack-simple#1.0 工程名字&lt;工程名字不能用中文&gt; 会有一些初始化的设置，如下输入: Target directory exists. Continue? (Y/n)直接回车默认(然后会下载 vue2.0模板，这里可能需要连代理)Project name (vue-test)直接回车默认Project description (A Vue.js project) 直接回车默认Author 写你自己的名字 cd 命令进入创建的工程目录工程目录如图所示: 安装项目依赖一定要从官方仓库安装，npm 服务器在国外所以这一步安装速度会很慢。 npm install 不要从国内镜像cnpm安装(会导致后面缺了很多依赖库) cnpm install 安装 vue 路由模块vue-router和网络请求模块vue-resource cnpm install vue-router vue-resource –save 启动项目 npm run dev 填坑(以下坑可能由于 vue2.0 导致其他相关编译打包工具没更新导致的) 【重点】后来发现这些坑是由于 npm 不是最新的版本3.10.2， 用 npm 3.9.5就会出现以下坑解决办法: 请运行以下命令npm update -g 报错 Error: Cannot find module ‘opn’Error: Cannot find module ‘webpack-dev-middleware’Error: Cannot find module ‘express’Error: Cannot find module ‘compression’Error: Cannot find module ‘sockjs’Error: Cannot find module ‘spdy’Error: Cannot find module ‘http-proxy-middleware’Error: Cannot find module ‘serve-index’ 如果你用的是老版本的 vue-cli 还可能报其他错误，需要更新一下 vue-cli npm update vue-cli 然后可以查看一下当前全局 vue-cli 的版本 npm view vue-cli 安装一下这个依赖到工程开发环境 cnpm install opn –save-devcnpm install webpack-dev-middleware –save-devcnpm install express –save-devcnpm install compression –save-devcnpm install sockjs –save-devcnpm install spdy –save-devcnpm install http-proxy-middleware –save-devcnpm install serve-index –save-devcnpm install connect-history-api-fallback –save-dev 再启动项目，报错 ERROR in ./src/main.jsModule build failed: Error: Cannot find module ‘babel-runtime/helpers/typeof’at Function.Module._resolveFilename (module.js:440:15)at Function.Module._load (module.js:388:25)at Module.require (module.js:468:17)at require (internal/module.js:20:19)at Object. (/Volumes/MacStorage/Coding/Web/vue-test/node_modules/.6.17.0@babel-core/lib/transformation/file/index.js:6:16)at Module._compile (module.js:541:32)at Object.Module._extensions..js (module.js:550:10)at Module.load (module.js:458:32)at tryModuleLoad (module.js:417:12)at Function.Module._load (module.js:409:3)@ multi mainERROR in ./~/.2.1.0-beta.8@webpack-dev-server/client/socket.jsModule not found: Error: Can’t resolve ‘sockjs-client’ in ‘/Volumes/MacStorage/Coding/Web/vue-test/node_modules/.2.1.0-beta.8@webpack-dev-server/client’@ ./~/.2.1.0-beta.8@webpack-dev-server/client/socket.js 1:13-37@ ./~/.2.1.0-beta.8@webpack-dev-server/client?http://localhost:8080@ multi main 安装一下 babel-runtime cnpm install babel-helpers –save-dev 启动项目，再次报错 Module build failed: Error: Cannot find module ‘babel-helpers’Module build failed: Error: Cannot find module ‘babel-traverse’Module build failed: Error: Cannot find module ‘json5’Module build failed: Error: Cannot find module ‘babel-generator’Module build failed: Error: Cannot find module ‘detect-indent’Module build failed: Error: Cannot find module ‘jsesc’ 找不到依赖那就再安装一下 cnpm install babel-helpers –save-devcnpm install babel-traverse –save-devcnpm install json5 –save-dev...不写了，请把全部把旧的环境全部清除，更新到最新版本 解决办法概述遇到 Module build failed: Error: Cannot find module ‘模块名’ 那就安装 cnpm install 模块名 –save-dev(关于环境的，表现为npm run dev 启动不了)cnpm install 模块名 –save(关于项目的，比如main.js，表现为npm run dev 成功之后控制台报错)比如escape-string-regexp、strip-ansi、has-ansi、is-finite、emojis-list 终于可以启动项目了输入完命令会自动启动浏览器，如果默认打开 IE 不行 npm run dev 自动启动浏览器就会看到这 帅帅的界面了。 开始 Vue 之旅打开 IDE推荐 Atom 打开项目，需要安装 Vue 语法高亮的插件 使用官网文档学习基础我们来看官网的一个例子，(中文文档请自行上网搜索) ￼ 打开 工程目录下的 App.vue template 写 html，script写 js，style写样式 为了方便叙述，我们把官网例子写在同一个组件内 这里有两个坑: 第一。一个组件下只能有一个并列的 div，可以这么写，所以复制官网示例的时候只要复制 div 里面的内容就好。 但是不能这样写: ￼ 第二。数据要写在 return 里面而不是像文档那样子写 错误的写法: 这样子可以自己啃完官网文档组件之前的部分了。 来玩玩组件前面讲得基本上都是各种常用组件的数据绑定，下面还得说说的是 Vue 的组件的使用。 在工程目录/src下创建component文件夹，并在component文件夹下创建一个 firstcomponent.vue并写仿照 App.vue 的格式和前面学到的知识写一个组件。 12345678910111213141516171819&lt;template&gt; &lt;div id=\"firstcomponent\"&gt; &lt;h1&gt;I am a title.&lt;/h1&gt; &lt;a&gt; written by &#123;&#123; author &#125;&#125; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=\"text/javascript\"&gt;export default &#123; data () &#123; return &#123; author: \"微信公众号 jinkey-love\" &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; duang… 不能按官网文档那样子叫我做就做，我得先试试再告诉你，我做完效果是这样子的，希望观众做完也是这样子。(迷之微笑 ) 然后在 App.vue 使用组件 ( 因为在 index.html 里面定义了所以就以这个组件作为主入口，方便 ) 第一步，引入。在&lt;script&gt;&lt;/script&gt;标签内的第一行写 1import firstcomponent from './component/firstcomponent.vue' 第二步，注册。在&lt;script&gt;&lt;/script&gt;标签内的 data 代码块后面加上 components: { firstcomponent }。记得中间加英文逗号!!! 12345678export default &#123; data () &#123; return &#123; msg: 'Hello Vue!' &#125; &#125;, components: &#123; firstcomponent &#125;&#125; 第三步，使用。 在&lt;template&gt;&lt;/template&gt;内加上 1234567&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;firstcomponent&gt;&lt;/firstcomponent&gt; &lt;/div&gt;&lt;/template&gt; 完成后的代码： 这时候看看浏览器上的 http://localhost:8080/ 页面(之前打开过就会自动刷新)，如果你没看到效果是因为你没有对 App.vue 和 firstcomponent.vue 进行保存操作，保存后页面会自动刷新。 使用路由搭建单页应用之前已经通过命令安装了vue-router cnpm install vue-router –save 在webpack.config.js加入别名 123resolve: &#123; alias: &#123;vue: 'vue/dist/vue.js'&#125;&#125; 为什么要加 alias 配置项？其作用可以在文档中有相应的描述: 修改完之后的webpack.config.js是这样子的:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'build.js' &#125;, resolveLoader: &#123; root: path.join(__dirname, 'node_modules'), &#125;, module: &#123; loaders: [&#123; test: /\\\\\\\\\\\\\\\\.vue$/, loader: 'vue' &#125;, &#123; test: /\\\\\\\\\\\\\\\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, &#123; test: /\\\\\\\\\\\\\\\\.(png|jpg|gif|svg)$/, loader: 'file', query: &#123; name: '[name].[ext]?[hash]' &#125; &#125;] &#125;, resolve: &#123; alias: &#123; vue: 'vue/dist/vue.js' &#125; &#125;, devServer: &#123; historyApiFallback: true, noInfo: true &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ])&#125; 再按之前的方法写一个组件 secondcomponent.vue 123456789101112131415161718192021&lt;template&gt; &lt;div id=\"secondcomponent\"&gt; &lt;h1&gt;I am another page&lt;/h1&gt; &lt;a&gt; written by &#123;&#123; author &#125;&#125; &lt;/a&gt; &lt;p&gt; 感谢 &lt;a href=\"https://github.com/showonne\"&gt;showonne&lt;/a&gt;大神的技术指导&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; author: \"微信公众号 jinkey-love\", articles: [], &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 这时候修改 main.js，引入并注册 vue-router 12import VueRouter from \"vue-router\";Vue.use(VueRouter); 并且配置路由规则和 app 启动配置项加上 router，旧版的 router.map 方法在 vue-router 2.0 已经不能用了。修改后的main.js如下: 12345678910111213141516171819202122232425262728293031323334353637import Vue from 'vue'import App from './App.vue'import VueRouter from \"vue-router\";import VueResource from 'vue-resource'//开启debug模式Vue.config.debug = true;Vue.use(VueRouter);Vue.use(VueResource);// 定义组件, 也可以像教程之前教的方法从别的文件引入const First = &#123; template: '&lt;div&gt;&lt;h2&gt;我是第 1 个子页面&lt;/h2&gt;&lt;/div&gt;'&#125;import secondcomponent from './component/secondcomponent.vue'// 创建一个路由器实例// 并且配置路由规则const router = new VueRouter(&#123; mode: 'history', base: __dirname, routes: [&#123; path: '/first', component: First &#125;, &#123; path: '/second', component: secondcomponent &#125;]&#125;)// 现在我们可以启动应用了！// 路由器会创建一个 App 实例，并且挂载到选择符 #app 匹配的元素上。const app = new Vue(&#123; router: router, render: h =&gt; h(App)&#125;).$mount('#app') 这样子改完再打开浏览器看看。 点击那两个链接试试，会发现&lt;router-view class=&quot;view&quot;&gt;&lt;/router-view&gt;的内容已经展示出来，同时注意浏览器地址已经变更。 另外，也可以把 App.vue 的内容写在 main.js 也是可以的不过不建议这么做 如果你使用 vue1.0和0.7版本的 vue-router，请参照下面这个教程, 他整个系列都不错的，当然仅限于 vue1.0 : http://guowenfh.github.io/2016/03/28/vue-webpack-06-router/ 给页面加点动态数据这时候的页面都是静态的(数据在写程序的时候已经固定了不能修改)，而每个应用基本上都会请求外部数据以动态改变页面内容。对应有一个库叫 vue-resource 帮我们解决这个问题。 使用命令行安装 cnpm install vue-resource –save 在 main.js 引入并注册 vue-resource: 12import VueResource from 'vue-resource'Vue.use(VueResource); 我们在 secondcomponent.vue 上来动态加载数据 添加一个列表:12345&lt;ul&gt; &lt;li v-for=\"article in articles\"&gt; &#123;&#123;article.title&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 在 data 里面加入数组 articles 并赋值为[]然后在 data 后面加入加入钩子函数 mounted(详细请参照官方文档关于 vue 生命周期的解析)，data 和 mount 中间记得记得加逗号1234567891011121314151617mounted: function() &#123; this.$http.jsonp('https://api.douban.com/v2/movie/top250?count=10', &#123;&#125;, &#123; headers: &#123; &#125;, emulateJSON: true &#125;).then(function(response) &#123; // 这里是处理正确的回调 this.articles = response.data.subjects // this.articles = response.data[\"subjects\"] 也可以 &#125;, function(response) &#123; // 这里是处理错误的回调 console.log(response) &#125;);&#125; 这里使用的是豆瓣的公开 GET 接口，如果接口是跨域的 POST 请求，则需要在服务器端配置: Access-Control-Allow-Origin: * 这时候运行看看。等一会接口返回数据，咦，数据加载出来了，棒棒哒 ! 更多 vue-router 的使用方法可以看 vue-router 0.7http://m.doc00.com/doc/1001004egvue-router 2.0http://router.vuejs.org/zh-cn/index.html 来拯救如此难看的界面组件、双向绑定、路由、数据请求等基本特性都能用了，写到这里一个单页应用基本上成型了。但是，这几面也太 TM 难看了吧。自己写 UI 框架太费劲？那就上网找一个吧。本来想给大家介绍 Vux 的，因为他用的是微信的 WeUI 设计规范，对于开发微信小程序或者微信内的网页非常和谐，但由于写这篇文章的时候 Vux 还不支持 vue2.0，只能用别的框架了。命令行安装 ElementUI (此处某公司的人应该发红包了…) cnpm install element-ui@next -S 然后在 main.js 引入并注册 123import Element from 'element-ui'import 'element-ui/lib/theme-default/index.css'Vue.use(Element) 保存，这时候程序报错 Uncaught Error: Module parse failed: /Users/**/Desktop/vue2/node_modules/.1.0.0-rc.5@element-ui/lib/theme-default/index.css Unexpected character ‘@’ (1:0)You may need an appropriate loader to handle this file type. 官网文档又有坑了，安装教程也不跟我们说这一步，当我们都是高手了…报错是由于我们引入了index.css这个 CSS 文件，但是 webpack 打包的时候无法识别并转换成 js，所以就需要配置才能读取 css 和字体文件，运行命令安装下面三个东西(如果之前安装过就不需要了) cnpm install style-loader –save-devcnpm install css-loader –save-devcnpm install file-loader –save-dev 在 webpack.config.js 中的 loaders 数组加入以下配置，记得该加逗号的地方加逗号! 12345678&#123; test: /\\\\\\\\\\\\\\\\.css$/, loader: \"style!css\"&#125;,&#123; test: /\\\\\\\\\\\\\\\\.(eot|woff|woff2|ttf)([\\\\\\\\\\\\\\\\?]?.*)$/, loader: \"file\"&#125; 修改完的 webpack.config.js 如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'build.js' &#125;, resolveLoader: &#123; root: path.join(__dirname, 'node_modules'), &#125;, module: &#123; loaders: [&#123; test: /\\\\\\\\\\\\\\\\.vue$/, loader: 'vue' &#125;, &#123; test: /\\\\\\\\\\\\\\\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, &#123; test: /\\\\\\\\\\\\\\\\.css$/, loader: \"style!css\" &#125;, &#123; test: /\\\\\\\\\\\\\\\\.(eot|woff|woff2|ttf)([\\\\\\\\\\\\\\\\?]?.*)$/, loader: \"file\" &#125;, &#123; test: /\\\\\\\\\\\\\\\\.(png|jpg|gif|svg)$/, loader: 'file', query: &#123; name: '[name].[ext]?[hash]' &#125; &#125;] &#125;, resolve: &#123; alias: &#123; vue: 'vue/dist/vue.js' &#125; &#125;, devServer: &#123; historyApiFallback: true, noInfo: true &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ])&#125; 给豆瓣的电影列表套个衣服(样式) : 12345678&lt;el-card class=\"box-card\"&gt; &lt;div slot=\"header\" class=\"clearfix\"&gt; &lt;h1 style=\"line-height: 36px; color: #20A0FF\"&gt;豆瓣电影排行榜&lt;/h2&gt; &lt;/div&gt; &lt;div v-for=\"article in articles\" class=\"text item\"&gt; &#123;&#123;article.title&#125;&#125; &lt;/div&gt;&lt;/el-card&gt; 打开浏览器,输入网址: http://localhost:8080/second ￼列表比之前漂亮多了，你还可以参照 ElementUI 的文档使用更多组件样式 http://element.eleme.io/#/component/layout 编译 npm run build 又报错了…orz ERROR in build.js from UglifyJsSyntaxError: Unexpected token punc «(», expected punc «:» [build.js:32001,6]把node_modules/.bin/cross-env里的require(‘../dist’)(process.argv.slice(2)); 后来发现直接运行 webpack 命令就可以打包了 webpack –color –progress 接着把 index.html 和整个 dist 目录丢到服务器就可以了。","pubDate":"Thu, 13 Oct 2016 02:31:35 GMT","guid":"https://aotu.io/notes/2016/10/13/vue2/","category":"Web开发"},{"title":"H5直播起航","link":"https://aotu.io/notes/2016/10/09/HTML5-SopCast/","description":"前言前不久抽空对目前比较火的视频直播，做了下研究与探索，了解其整体实现流程，以及探讨移动端HTML5直播可行性方案。 发现目前 WEB 上主流的视频直播方案有 HLS 和 RTMP，移动 WEB 端目前以 HLS 为主（HLS存在延迟性问题，也可以借助 video.js 采用RTMP），PC端则以 RTMP 为主实时性较好，接下来将围绕这两种视频流协议来展开H5直播主题分享。 一、视频流协议HLS与RTMP1. HTTP Live StreamingHTTP Live Streaming（简称 HLS）是一个基于 HTTP 的视频流协议，由 Apple 公司实现，Mac OS 上的 QuickTime、Safari 以及 iOS 上的 Safari 都能很好的支持 HLS，高版本 Android 也增加了对 HLS 的支持。一些常见的客户端如：MPlayerX、VLC 也都支持 HLS 协议。 HLS 协议基于 HTTP，而一个提供 HLS 的服务器需要做两件事： 编码：以 H.263 格式对图像进行编码，以 MP3 或者 HE-AAC 对声音进行编码，最终打包到 MPEG-2 TS（Transport Stream）容器之中； 分割：把编码好的 TS 文件等长切分成后缀为 ts 的小文件，并生成一个 .m3u8 的纯文本索引文件； 浏览器使用的是 m3u8 文件。m3u8 跟音频列表格式 m3u 很像，可以简单的认为 m3u8 就是包含多个 ts 文件的播放列表。播放器按顺序逐个播放，全部放完再请求一下 m3u8 文件，获得包含最新 ts 文件的播放列表继续播，周而复始。整个直播过程就是依靠一个不断更新的 m3u8 和一堆小的 ts 文件组成，m3u8 必须动态更新，ts 可以走 CDN。一个典型的 m3u8 文件格式如下： #EXTM3U #EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=200000gear1/prog_index.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=311111gear2/prog_index.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=484444gear3/prog_index.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1, BANDWIDTH=737777gear4/prog_index.m3u8 可以看到 HLS 协议本质还是一个个的 HTTP 请求 / 响应，所以适应性很好，不会受到防火墙影响。但它也有一个致命的弱点：延迟现象非常明显。如果每个 ts 按照 5 秒来切分，一个 m3u8 放 6 个 ts 索引，那么至少就会带来 30 秒的延迟。如果减少每个 ts 的长度，减少 m3u8 中的索引数，延时确实会减少，但会带来更频繁的缓冲，对服务端的请求压力也会成倍增加。所以只能根据实际情况找到一个折中的点。 对于支持 HLS 的浏览器来说，直接这样写就能播放了： 12&lt;video src=\"http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8\"height=\"300\" width=\"400\" preload=\"auto\" autoplay=\"autoplay\" loop=\"loop\" webkit-playsinline=\"true\"&gt;&lt;/video&gt; 注意：HLS 在 PC 端仅支持safari浏览器，类似chrome浏览器使用HTML5 video标签无法播放 m3u8 格式，可直接采用网上一些比较成熟的方案，如：sewise-player、MediaElement、videojs-contrib-hls、jwplayer。 2. Real Time Messaging ProtocolReal Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。这套方案需要搭建专门的 RTMP 流媒体服务如 Adobe Media Server，并且在浏览器中只能使用 Flash 实现播放器。它的实时性非常好，延迟很小，但无法支持移动端 WEB 播放是它的硬伤。 虽然无法在iOS的H5页面播放，但是对于iOS原生应用是可以自己写解码去解析的, RTMP 延迟低、实时性较好。 浏览器端，HTML5 video标签无法播放 RTMP 协议的视频，可以通过 video.js 来实现。 12345678910111213&lt;link href=\"http://vjs.zencdn.net/5.8.8/video-js.css\" rel=\"stylesheet\"&gt;&lt;video id=\"example_video_1\" class=\"video-js vjs-default-skin\" controls preload=\"auto\" width=\"640\" height=\"264\" loop=\"loop\" webkit-playsinline&gt; &lt;source src=\"rtmp://10.14.221.17:1935/rtmplive/home\" type='rtmp/flv'&gt;&lt;/video&gt;&lt;script src=\"http://vjs.zencdn.net/5.8.8/video.js\"&gt;&lt;/script&gt;&lt;script&gt;videojs.options.flash.swf = 'video.swf';videojs('example_video_1').ready(function() &#123; this.play();&#125;);&lt;/script&gt; 3. 视频流协议HLS与RTMP对比 协议 原理 延时 优点 使用场景 HLS 短链接Http 集合一段时间数据生成ts切片文件更新m3u8文件 10s - 30s 跨平台 移动端为主 RTMP 长链接Tcp 每个时刻的数据收到后立即发送 2s 延时低、实时性好 PC+直播+实时性要求高＋互动性强 二、直播形式 目前直播展示形式，通常以YY直播、映客直播这种页面居多，可以看到其结构可以分成三层：① 背景视频层 ② 关注、评论模块 ③ 点赞动画 而现行H5类似直播页面，实现技术难点不大，其可以通过实现方式分为：① 底部视频背景使用video视频标签实现播放 ② 关注、评论模块利用 WebScoket 来实时发送和接收新的消息通过DOM 和 CSS3 实现 ③ 点赞利用 CSS3 动画 了解完直播形式之后，接下来整体了解直播流程。 三、直播整体流程直播整体流程大致可分为： 视频采集端：可以是电脑上的音视频输入设备、或手机端的摄像头、或麦克风，目前以移动端手机视频为主。 直播流视频服务端：一台Nginx服务器，采集视频录制端传输的视频流(H264/ACC编码)，由服务器端进行解析编码，推送RTMP/HLS格式视频流至视频播放端。 视频播放端：可以是电脑上的播放器（QuickTime Player、VLC），手机端的native播放器，还有就是 H5 的video标签等，目前还是以手机端的native播放器为主。 四、H5 录制视频对于H5视频录制，可以使用强大的 webRTC （Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术，缺点是只在 PC 的 Chrome 上支持较好，移动端支持不太理想。 1. 使用 webRTC 录制视频基本流程① 调用 window.navigator.webkitGetUserMedia() 获取用户的PC摄像头视频数据。② 将获取到视频流数据转换成 window.webkitRTCPeerConnection (一种视频流数据格式)。③ 利用 WebScoket 将视频流数据传输到服务端。 注意：虽然Google一直在推WebRTC，目前已有不少成型的产品出现，但是大部分移动端的浏览器还不支持 webRTC（最新iOS 10.0也不支持），所以真正的视频录制还是要靠客户端（iOS,Android）来实现,效果会好一些。 2. iOS原生应用调用摄像头录制视频流程① 音视频的采集，利用AVCaptureSession和AVCaptureDevice可以采集到原始的音视频数据流。② 对视频进行H264编码，对音频进行AAC编码，在iOS中分别有已经封装好的编码库（x264编码、faac编码、ffmpeg编码）来实现对音视频的编码。③ 对编码后的音、视频数据进行组装封包。④ 建立RTMP连接并上推到服务端。 五、搭建Nginx+Rtmp直播流服务1. 安装nginx、nginx-rtmp-module① 先clone nginx项目到本地： 1brew tap homebrew/nginx ② 执行安装nginx-rtmp-module 1brew install nginx-full --with-rtmp-module 2. nginx.conf配置文件，配置RTMP、HLS查找到nginx.conf配置文件（路径/usr/local/etc/nginx/nginx.conf），配置RTMP、HLS。 ① 在http节点之前添加 rtmp 的配置内容： 12345678910111213141516171819rtmp &#123; server &#123; #监听的端口 listen 1935; # RTMP 直播流配置 application rtmplive &#123; live on; #为 rtmp 引擎设置最大连接数。默认为 off max_connections 1024; &#125; # HLS 直播流配置 application hls&#123; live on; hls on; hls_path /usr/local/var/www/hls; hls_fragment 1s; &#125; &#125;&#125; ② 在http中添加 hls 的配置 12345678910location /hls &#123; # Serve HLS fragments types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root /usr/local/var/www; #add_header Cache-Controll no-cache; expires -1; &#125; 3. 重启nginx服务重启nginx服务，浏览器中输入 http://localhost:8080，是否出现欢迎界面确定nginx重启成功。1nginx -s reload 六、直播流转换格式、编码推流当服务器端接收到采集视频录制端传输过来的视频流时，需要对其进行解析编码，推送RTMP/HLS格式视频流至视频播放端。通常使用的常见编码库方案，如x264编码、faac编码、ffmpeg编码等。 鉴于 FFmpeg 工具集合了多种音频、视频格式编码，我们可以优先选用FFmpeg进行转换格式、编码推流。 1.安装 FFmpeg 工具1brew install ffmpeg 2.推流MP4文件 视频文件地址：/Users/gao/Desktop/video/test.mp4推流拉流地址：rtmp://localhost:1935/rtmplive/home，rtmp://localhost:1935/rtmplive/home 12345//RTMP 协议流ffmpeg -re -i /Users/gao/Desktop/video/test.mp4 -vcodec libx264 -acodec aac -f flv rtmp://10.14.221.17:1935/rtmplive/home//HLS 协议流ffmpeg -re -i /Users/gao/Desktop/video/test.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -q 10 rtmp://10.14.221.17:1935/hls/test 注意： 当我们进行推流之后，可以安装VLC、ffplay（支持rtmp协议的视频播放器）本地拉流进行演示 3.FFmpeg推流命令 ① 视频文件进行直播 12ffmpeg -re -i /Users/gao/Desktop/video/test.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -q 10 rtmp://192.168.1.101:1935/hls/testffmpeg -re -i /Users/gao/Desktop/video/test.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -q 10 rtmp://10.14.221.17:1935/hls/test ② 推流摄像头＋桌面+麦克风录制进行直播 1ffmpeg -f avfoundation -framerate 30 -i \"1:0\" \\-f avfoundation -framerate 30 -video_size 640x480 -i \"0\" \\-c:v libx264 -preset ultrafast \\-filter_complex 'overlay=main_w-overlay_w-10:main_h-overlay_h-10' -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://192.168.1.101:1935/hls/test 更多命令，请参考：FFmpeg处理RTMP流媒体的命令大全 FFmpeg常用推流命令 七、H5 直播视频播放移动端iOS和 Android 都天然支持HLS协议，做好视频采集端、视频流推流服务之后，便可以直接在H5页面配置 video 标签播放直播视频。 1234&lt;video controls preload=\"auto\" autoplay=\"autoplay\" loop=\"loop\" webkit-playsinline&gt; &lt;source src=\"http://10.14.221.8/hls/test.m3u8\" type=\"application/vnd.apple.mpegurl\" /&gt; &lt;p class=\"warning\"&gt;Your browser does not support HTML5 video.&lt;/p&gt; &lt;/video&gt; ps：① video标签添加webkit-playsinline属性（iOS支持）是保证视频在网页中内嵌播放。② 针对微信浏览器，video标签层级最高的问题，需要申请添加白名单，请参照 http://bbs.mb.qq.com/thread-1242581-1-1.html?ptlang=2052。 八、总结本文从视频采集上传，服务器处理视频推流，以及H5页面播放直播视频一整套流程,具体阐述了直播实现原理，实现过程中会遇到很多性能优化问题。 ① H5 HLS 限制必须是H264+AAC编码。 ② H5 HLS 播放卡顿问题，server 端可以做好分片策略，将 ts 文件放在 CDN 上，前端可尽量做到 DNS 缓存等。 ③ H5 直播为了达到更好的实时互动，也可以采用RTMP协议，通过video.js实现播放。 参考资料： 如何搭建一个完整的视频直播系统？ WebRTC相关的canvas与video 使用 WebSockets 进行 HTML5 视频直播 关于直播，所有的技术细节都在这里了（一） 关于直播，所有的技术细节都在这里了（二） 关于直播，所有的技术细节都在这里了（三） JS解码项目jsmpeg","pubDate":"Sun, 09 Oct 2016 07:24:41 GMT","guid":"https://aotu.io/notes/2016/10/09/HTML5-SopCast/","category":"Web开发"},{"title":"A-Frame WebVR试玩报告","link":"https://aotu.io/notes/2016/10/08/aframe/","description":"什么叫真？你怎样给真下定义，如果你说真就是你能感觉到的东西，你能闻到的气味，你能尝到的味道，那么这个真只是你大脑作出反应的电子信号。 —— 《黑客帝国》 关于VR技术VR即Virtual Reality虚拟现实，大白话来讲，就是利用电脑创造一个全新的虚拟世界，通过欺骗你的感官（目前更多是视觉上），让你置身于一个与现实相似又完全虚拟的世界中，这就像是在《黑客帝国》中，主人公尼奥对这个看似真实的世界产生怀疑，在崔妮蒂的帮助下，最终与墨菲斯见面，并吃下了象征真相的红色药丸，在矩阵醒来后的尼奥发现，原来他一直生活在矩阵所创造的虚拟世界中。 一分钟VR简史《Pygmalion’s Spectacles》（《皮格马利翁的眼镜》） 虚拟现实这个概念最早来自于Stanley G. Weinbaum在1935年发表的科幻小说《皮格马利翁的眼镜》，被认为是探讨虚拟现实的第一部科幻作品，简短的故事中详细的描述了包括嗅觉、触觉和全息眼镜为基础的虚拟现实系统。 Sensorama VR的雏形，要追溯到1962年被称为虚拟现实之父Morton Heilig发明的Sensorama，它的外观就像是一个笨重的街机盒子。Morton Heilig发明Sensorama的初衷是为了打造未来的电影，在当时那个年代拍摄3D电影并不容易，Morton Heilig为了配合拍摄，又发明了3D摄像机和投影仪，为Sensorama拍摄了五部短片，以直升机、卡丁车、自行车和摩托车等骑行体验为主，Sensorama播放在布鲁克林骑摩托车的短片时能够提供真实的3D影像，感受行车时的颠簸，周围环境的立体声、迎面吹来的风和气味，这在当时大部分人都还在使用黑白电视的时代，是多么令人震撼的，遗憾的是该项目未能获得资金的支持，因此Sensorama的研发工作止步不前，最终回看历史，其实它更像是现代的4D电影。 The Sword of Damocles（达摩克利斯之剑） 1968年，Ivan Edward Sutherland和他的学生Bob Sproull在麻省理工学院的林肯实验室创造了第一个虚拟现实及增强现实头戴式显示器系统，第一个显示应用是悬浮在空中的一个立方体，这款头戴显示器因为要跟踪用户的视线，需要通过机械臂移动，因此设备非常笨重，只能挂在天花板上减轻重量使用，被戏称为“达摩克利斯之剑”。 Sega VR（世嘉VR）1991年世嘉宣布了Sega VR，定价为200美元，从1991年到1994年，世嘉就在起VR设备上不断宣传，并且在1993年的夏季CES展会上提供VR的试玩，就在大家万分期待之时，1994年世嘉表示停止该项目，给出的理由是虚拟现实效果过于逼真，同时佩戴耳机的用户有可能移动和伤害到自己，当然明白人都知道这是个借口，花了如此大力气的投入和探索最终却放弃了，原因或许是因为SEGA VR的游戏和软件太少了，在夏季CES展会上也只是公布了屈指可数的4款游戏：《Nuclear Rush》、《Iron Hammer》、《Matrix Runner》、《Outlaw Racing》。 Virtual Boy1995年，任天堂发布了Virtual Boy，Virtual Boy采用二极管和视差技术创造出游戏的3D效果，是任天堂在N64上市之前用来取代Game Boy的32位便携游戏机，由设计Game Boy的横井军平主导，最终发售22个游戏，全球销量77万台，造成其失败的原因很大程度是因为Virtual Boy只能提供红黑两色的游戏画面，760克的重量需要支架支撑，玩家只能卷缩身体坐着玩，并且玩家在过程中会有强烈的眩晕感。 Oculus RiftVR这个词在近两年火热起来也正是因为Oculus Rift，92年生的Palmer Freeman Luckey对任何事物皆有好奇其心的人，喜欢收藏各类VR设备，并且是Meat to be seen技术论坛的版主，Palmer对市面上VR的低对比度、高延迟和低视野感到失望，他希望制作一个能跟踪玩家头部转动的360度全景，并以极低的延迟显示画面的VR头戴设备。 同样作为Meat to be seen技术论坛成员之一的FPS之父卡约翰·卡马克，看到此项目非常感兴趣，要求给予一台原型机，并对《DOOM3》进行VR适配，在2012年E3展出此设备，获得了E3最佳外设奖，一时间获得各大媒体的关注，随后在Kickstarter发起众筹，短时间内就获得超过9500人支持，总资金达243万美金。 在2014年7月，Oculus Rift被Facebook以20亿美元收购后，各个厂家似乎又看到另一片蓝海，大量的涌入这个市场，HTC的HTC Vive，索尼的PlayStation VR，各类的手机VR等等。 关于A-Frame 历史讲完回到正题，Mozilla认为目前的WebVR发展太困难了，为了使其更加快速、方便、愉快的打造3D/VR场景，2015年12月16日Mozilla旗下的MozVR团队，在经过长时间的试验，并且从一些3D/VR工具（例如：JanusVR、GLAM、SceneVR）中汲取经验，公布了JavaScript开源框架A-Frame。 A-Frame使用Web开发者熟悉的HTML标签来创建WebVR场景，使得非WebGL开发者无需学习强大而又复杂的WebGL API来创建VR场景，降低了初学者学习的门槛，并且A-Frame一个最大的优势在于跨平台性，目前版本已迭代到v0.3.0，支持VR头戴设备Oculus Rift和HTC Vive以及非VR设备的PC端和Mobile端（可开启VR模式，利用Google Cardboard、Gear VR等设备观看）。 简单概括A-Frame特点如下： 结合three.js和WebGL的力量 通过自定义标签创建WebVR，标签具有可读性 具有跨平台性，支持PC端、Mobile端以及头戴设备Oculus Rift和HTC Vive 减少开发成本，降低初学者与牛人之间学习曲线 底层模块化和可扩展性 A-Frame功能A-Frame为开发者提供了许多的功能模块，例如在官网Docs里Primitives提供了基础的几何形状（盒子、球面、圆柱、平面等）、可导入3D建模工具制作或从网上下载的Collada模型、定义背景的天空、定义用户从哪个角度观看场景的相机、动画、光影、全景视频等功能，通过标签开发者就可以轻松的创建WebVR场景，更多功能可以到官网查看。 A-Frame实例这里以官网的一个例子作为基础讲讲怎么使用A-Frame。 1、创建场景12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;script src=\"aframe-v0.3.0.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a-scene&gt; &lt;/a-scene&gt; &lt;/body&gt;&lt;/html&gt; &lt;a-scene&gt;是一个全局的根对象，所有实体都存在于这个场景中，&lt;a-scene&gt;处理了所有three.js和WebVR boilerplate需要做的事： 创建画布，渲染器以及渲染循环 默认的相机和光影 创建WebVR Polyfill，VREffect 添加用户界面进入VR，调用WebVR API 2、创建天空 123456&lt;a-scene&gt; &lt;a-assets&gt; &lt;img id=\"lake\" src=\"lake.jpg\"&gt; &lt;/a-assets&gt; &lt;a-sky src=\"#lake\"&gt;&lt;/a-sky&gt;&lt;/a-scene&gt; &lt;a-sky&gt;允许为场景设置纯色背景或是一张360度全景图片，&lt;a-assets&gt;则是预加载WebVR页面所需的资源。 点击查看DEMO 3、创建相机12345&lt;a-scene&gt; &lt;a-entity position=\"0 0 3.8\"&gt; &lt;a-camera&gt;&lt;/a-camera&gt; &lt;/a-entity&gt;&lt;/a-scene&gt; &lt;a-camera&gt;定义了用户从哪个角度观看场景，改变&lt;a-camera&gt;的position需要将其置于&lt;a-entity&gt;中，直接在&lt;a-camera&gt;设置不会生效。 4、创建球面、立方体、圆柱、平面12345678910&lt;a-scene&gt; &lt;!-- 球面 --&gt; &lt;a-sphere position=\"0 1.25 -1\" radius=\"1.25\" color=\"#ef2d5e\"&gt;&lt;/a-sphere&gt; &lt;!-- 立方体 --&gt; &lt;a-box position=\"-1 0.5 1\" rotation=\"0 45 0\" width=\"1\" height=\"1\" depath=\"1\" color=\"#4cc3d9\"&gt;&lt;/a-box&gt; &lt;!-- 圆柱 --&gt; &lt;a-cylinder position=\"1 0.75 1\" radius=\"0.5\" height=\"1.5\" color=\"#ffc65d\"&gt;&lt;/a-cylinder&gt; &lt;!-- 平面 --&gt; &lt;a-plane rotation=\"-90 0 0\" width=\"4\" height=\"4\" color=\"#7bc8a4\"&gt;&lt;/a-plane&gt;&lt;/a-scene&gt; position定位实体x、y、z轴的位置 rotation调整实体x、y、z轴的旋转角度 color改变实体的颜色 depth景深 width、height设置实体的宽高 radius圆角半径 数值是以“米”为单位 点击查看DEMO 5、添加动画1234567891011121314&lt;a-scene&gt; &lt;a-sphere position=\"0 1.25 -1\" radius=\"1.25\" color=\"#ef2d5e\"&gt; &lt;!-- 缩放 --&gt; &lt;a-animation attribute=\"scale\" from=\"1 1 1\" to=\"1.2 1.2 1.2\" repeat=\"indefinite\" direction=\"alternate\" dur=\"2000\"&gt;&lt;/a-animation&gt; &lt;/a-sphere&gt; &lt;a-box position=\"-1 0.5 1\" rotation=\"0 45 0\" width=\"1\" height=\"1\" depath=\"1\" color=\"#4cc3d9\"&gt; &lt;!-- 旋转 --&gt; &lt;a-animation attribute=\"rotation\" from=\"0 45 0\" to=\"0 360 0\" repeat=\"indefinite\" direction=\"alternate\"&gt;&lt;/a-animation&gt; &lt;/a-box&gt; &lt;a-cylinder position=\"1 0.75 1\" radius=\"0.5\" height=\"1.5\" color=\"#ffc65d\"&gt; &lt;!-- 改变高度 --&gt; &lt;a-animation attribute=\"height\" from=\"1.5\" to=\"0\" repeat=\"indefinite\" direction=\"alternate\"&gt;&lt;/a-animation&gt; &lt;/a-cylinder&gt;&lt;/a-scene&gt; 需要为某个实体添加动画则将&lt;a-animation&gt;置于标签之内，这里我给球scale缩放，立方体rotation360度Y轴旋转，圆柱改变height，并且无限次轮流反向播放动画。 attribute定义要执行的动画属性 from动画的起始 to动画的结束 repeat定义了要循环的次数，可以是一个数字或indefinite表示无限循环 dur动画的时长 direction动画轮流反向播放 A-Frame的动画属性与CSS3 animation非常相似，还有填充模式fill、延时delay、速度曲线easing等等。 点击查看DEMO 6、创建光标通过给相机增加一个光标cursor，让我们可以通过点击和注视与实体互动。1234567891011&lt;a-scene&gt; &lt;a-box cursor-listener position=\"-1 0.5 1\" rotation=\"0 45 0\" width=\"1\" height=\"1\" depath=\"1\" color=\"#4cc3d9\"&gt; &lt;a-animation attribute=\"rotation\" from=\"0 45 0\" to=\"0 360 0\" repeat=\"indefinite\" direction=\"alternate\"&gt;&lt;/a-animation&gt; &lt;/a-box&gt; &lt;a-entity position=\"0 0 3.8\"&gt; &lt;a-camera&gt; &lt;!-- 创建光标 --&gt; &lt;a-cursor color=\"#000\"&gt;&lt;/a-cursor&gt; &lt;/a-camera&gt; &lt;/a-entity&gt;&lt;/a-scene&gt; 1234567891011// 添加光标监听器AFRAME.registerComponent(\"cursor-listener\", &#123; init: function() &#123; var COLORS = [\"#6c8cbf\", \"#e4f0ff\", \"#6c70e1\"]; // 点击随机改变立方体颜色 this.el.addEventListener(\"click\", function() &#123; var randomIndex = Math.floor(Math.random() * COLORS.length); this.setAttribute(\"color\", COLORS[randomIndex]); &#125;); &#125;&#125;); 点击查看DEMO A-Frame社区一个框架是否能持续发展，很大程度看社区的活跃状态，A-Frame目前在Github上已经超过3500个star，Mozilla鼓励开发者们加入1400人的A-Frame Slack聊天组，并在社区中分享自己的作品，在A-Frame Twitter里，每周都会精选出优秀的A-Frame作品供开发者们参考学习。 在A-Frame的Github Roadmap后续的版本更新线路图中表明，后续除了常规的升级外还将推出教程（制作更多的学习资源、文章、指南、录屏）帮助初学者更好学习。 A-Frame资源 可视化在线编辑器 360全景图素材 flickr 500px 3D模型免费素材 Clara.io 3D Warehouse Archive 3D Turbosquid 资源集 awesome-aframe 参考资料： http://en.wikipedia.org/wiki/Virtual_reality https://en.wikipedia.org/wiki/Sensorama https://en.wikipedia.org/wiki/Sega_VR https://en.wikipedia.org/wiki/Virtual_Boy https://en.wikipedia.org/wiki/Oculus_Rift http://aframe.io/ https://github.com/aframevr/aframe https://twitter.com/aframevr","pubDate":"Sat, 08 Oct 2016 03:05:14 GMT","guid":"https://aotu.io/notes/2016/10/08/aframe/","category":"Web开发"},{"title":"在网页上实现 3D Touch 效果","link":"https://aotu.io/notes/2016/09/28/3d-touch/","description":"9 月 14 日凌晨，iOS 10 正式版开始向用户推送更新，而 iOS 10 搭载的 Safari 10 亦带来了不少新特性，其中就有 3D Touch 事件的支持（官方文档 《What’s New in Safari 10》）。 Force Touch 与 3D Touch说到 3D Touch 不能不提与之相似的 Force Touch。Force Touch是苹果公司在 2014 年 9 月公布的一项压力敏感屏幕技术，最早用于 Apple Watch ，可识别轻点、轻按两种操作。随后 Force Touch 于 2015 年 9 月在 iPhone 6s 上得到改进并更名为 3D Touch，提供了更高灵敏度的触控力度识别、及更强的触感反馈，支持轻点、轻按及重按三个维度。 硬件要求支持 3D Touch 的设备，目前有 iPhone 6s、iPhone 6s Plus、iPhone 7 以及 iPhone 7 Plus。 感受 3D Touch3D Touch 最为典型的交互有 Quick Actions 和 Peek and Pop 两种。在 APP 图标上重按呼出一组快捷操作菜单，这即是典型的 Quick Actions: 而使用 Peek and Pop 则可以快速地对内容进行预览，以及后续的其他操作： 如上图所示，在系统的邮件 APP 中，以一定的力度按压邮件列表中的某一项，会触发 Peek 弹出一个内容预览窗口（在 Peek 状态下上滑还能触发 Quick Actions 调出一些快捷操作项哦），如果继续加大按压力度，则会触发 Pop 进入邮件内容界面，这整个过程就称之为 Peek and Pop。 除了邮件 APP 以外，信息、照片等多个系统 APP 以及一些第三方 APP （如 微信、Facebook、Twitter 等）也都很好的支持了 Peek and Pop 这种 3D Touch 交互形式。 网页中的 3D Touch要在网页中实现 3D Touch，需要用到以下两个知识点： 1、Touch.force 在 touch 对象中包含有一个名为 force 的只读属性，它的取值从 0 到 1，表示的是触碰点的按压力度，0 表示没有检测到压力，而 1 则是设备能识别出的最大压力 2、touchforcechange touchforcechange 是 Safari 10 新增的事件，该事件会在按压力度改变时被触发 （注：在 MacOS Safari 上也有与之对应的 webkitmouseforcechanged 事件，该事件会在支持 Force Touch 的 Trackpad 上反应出按压力度值 force 的变化，但本文仅讨论手机设备的情况） 实现 3D Touch 效果要实现 3D Touch 效果，关键在于实时地获取 Touch.force 的值。而由于网页上的 3D Touch 很大程度上受限于设备及浏览器的支持情况，因此我们划分以下 3 种情况，分别来看看要如何实现 1、支持 3D Touch 且升级到了 iOS 10 的设备 在这种最为理想的情况下，只需要监听 touchforcechange 事件即可获取到 force 的当前值，将 force 值的变化以适当的形式反馈在界面上以实现 3D Touch 效果。 2、支持 3D Touch 但系统版本低于 iOS 10 的设备 这种情况虽然无法监听 touchforcechange 事件，但 Touch 对象的 force 属性仍然可以反应出正确的按压力度，可以巧妙地设置一个定时器，以轮询的方式获取 force 的当前值 3、不支持 3D Touch 的设备 这种情况下 Touch.force 的取值始终为 0，虽然可以用长按的交互形式来代替，但建议还是以优雅降级的方式，索性就不处理了吧 一个 3D Touch 的例子看到这里你肯定想说 “Shut up and show me the code…” 好的，那我们来看一个例子，在这个事例页面，用支持 3D Touch 的设备按压蓝色按钮可以将树懒兄逗笑哦，嘿嘿嘿~ 你可扫描以上二维码，或戳我进行预览，注意请使用 iOS Safari 浏览器进行访问！使用 iOS Safari 浏览器！！使用 iOS Safari 浏览器！！！重要的事情要说三遍。。因为目前微信 WebView 并不支持 3D Touch。 实现思路其实比较简单，根据刚刚说到的知识，我们分别监听 touchforcechange、touchstart、touchend、touchcancel 事件 在 touchstart 事件中，启动一个定时器轮询地去获取 Touch.force 的值； 在 touchforcechange 事件中获取当前 Touch.force 的值，并清除 touchstart 事件中设置的定时器，因为支持 touchforcechange 事件的话就没必要轮询了； 在 touchend 及 touchcancel 事件中把 Touch.force 重置为 0，并清除定时器。 而树懒兄大笑的动画则用的是以下这张雪碧图，根据当前 Touch.force 值来设置 background-position 以显示对应的动画帧来实现的 你可以访问这个 Github 项目 来查看源码，核心代码位于 ThreeDTouch.js，该文件封装了一个名为 ThreeDTouch 的类，事例化时传入一个 DOM 对象即可在 callback 中获取到按压力度值的变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 3D Touch 事件处理器，传入要监听的 DOM 对象，在 callback 回调中获取当前 force 值 * * @param &#123; HTMLElement &#125; el - 要监听的 DOM 对象 * @param &#123; Function &#125; callback - 带有 force 值的回调函数 * */function ThreeDTouch(el, callback) &#123; this.el = el this.callback = callback this._bindEvents()&#125;ThreeDTouch.prototype = &#123; //绑定相关 touch 事件 _bindEvents: function() &#123; var events = ['touchforcechange', 'touchstart', 'touchend', 'touchcancel'] events.forEach(function(event) &#123; this.el.addEventListener(event, this, false) &#125;.bind(this)) &#125;, //分派 touch 事件 handleEvent: function(ev) &#123; switch (ev.type) &#123; case 'touchforcechange': this._touchForceDidChange(ev) break case 'touchstart': this._touchDidStart(ev) break case 'touchend': case 'touchcancel': this._touchDidEnd(ev) &#125; &#125;, //force 值改变时 _touchForceDidChange: function(ev) &#123; var force = ev.touches[0].force this.callback(force) clearTimeout(this.timeoutId) //支持 touchforcechange 的话则取消轮询 &#125;, _touchDidStart: function(ev) &#123; var touch = ev.touches[0] this._checkForce(touch) &#125;, _touchDidEnd: function(ev) &#123; this.callback(0) clearTimeout(this.timeoutId) &#125;, //轮询地获取 force 值 _checkForce: function(touch) &#123; this.callback(touch.force) this.timeoutId = setTimeout(this._checkForce.bind(this, touch), 16) &#125;&#125; 参考 https://developer.apple.com/…/WhatsNewInSafari/Articles/Safari_10_0.html https://developer.mozilla.org/en-US/docs/Web/API/Force_Touch_events https://github.com/stuyam/pressure","pubDate":"Wed, 28 Sep 2016 08:00:00 GMT","guid":"https://aotu.io/notes/2016/09/28/3d-touch/","category":"Web开发"},{"title":"HTTP 缓存","link":"https://aotu.io/notes/2016/09/22/http-caching/","description":"有时，HTTP 中的缓存可能会非常让人头疼。按照文档正确地使用 HTTP 并不是那么困难，但事实上，不同的浏览器和 HTTP 版本常常困扰着我们。","pubDate":"Thu, 22 Sep 2016 08:38:12 GMT","guid":"https://aotu.io/notes/2016/09/22/http-caching/","category":"Web开发"},{"title":"通过 Babel 使用 ES6 的 import","link":"https://aotu.io/notes/2016/09/22/es6-import-with-babel/","description":"在《Modules with CommonJS》一文中，我们通过类似于 Python 的 import 方式，把我们的代码组织成模块。那篇文章展示了 NodeJS 的原生模块系统 – CommonJS。同时，文章还阐述了在那些不支持模块和模块加载器的浏览器中，如何使用 Webpack 去解决这种兼容性问题。","pubDate":"Thu, 22 Sep 2016 07:28:59 GMT","guid":"https://aotu.io/notes/2016/09/22/es6-import-with-babel/","category":"Web开发"},{"title":"写给新人的call、apply、bind","link":"https://aotu.io/notes/2016/09/02/Different-Binding/","description":"1、call()语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) thisArg：fun函数运行时指定的this值，可能的值为： 不传，或者传null，undefined， this指向window对象 传递另一个函数的函数名fun2，this指向函数fun2的引用 值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean 传递一个对象，函数中的this指向这个对象 例如： 123456function a()&#123; console.log(this);&#125;function b()&#123;&#125;a.call(b); // function b()&#123;&#125; 经常会看到这种使用情况： 12345function list() &#123; // 将arguments转成数组 return Array.prototype.slice.call(arguments); &#125;list(1,2,3); // [1, 2, 3] 为什么能实现这样的功能将arguments转成数组？首先call了之后，this指向了所传进去的arguments。我们可以假设slice方法的内部实现是这样子的：创建一个新数组，然后for循环遍历this，将this[i]一个个地赋值给新数组，最后返回该新数组。因此也就可以理解能实现这样的功能了。 2、apply()语法： 123// Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。// thisArg的可能值和call一样fun.apply(thisArg[, argsArray]) 例如： 123var numbers = [5, 6, 2, 3, 7];var max = Math.max.apply(null, numbers);console.log(max) // 7 平时Math.max只能这样子用：Math.max(5,6,2,3,7);利用apply的第二个参数是数组的特性，从而能够简便地从数组中找到最大值。 3、bind基本用法语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]); bind()方法会创建一个新函数，称为绑定函数。 bind是ES5新增的一个方法，不会执行对应的函数（call或apply会自动执行对应的函数），而是返回对绑定函数的引用。 当调用这个绑定函数时，thisArg参数作为 this，第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 简单地说，bind会产生一个新的函数，这个函数可以有预设的参数。 123456789function list() &#123; // 将arguments转成数组 return Array.prototype.slice.call(arguments); &#125;var leadingThirtysevenList = list.bind(undefined, 37); // 绑定函数var list = leadingThirtysevenList(1, 2, 3); // 调用绑定函数console.log(list); // [37, 1, 2, 3] bind调用简单把类数组换成真正的数组，bind能够更简单地使用： apply用法 123var slice = Array.prototype.slice;// ...slice.apply(arguments); // 类似对象的方法那样调用 bind用法 1234var unboundSlice = Array.prototype.slice;var slice = Function.prototype.apply.bind(unboundSlice);// ...slice(arguments); // 直接调用，简单 4、它们的区别相同之处：改变函数体内 this 的指向。不同之处： call、apply的区别：接受参数的方式不一样。 bind：不立即执行。而apply、call 立即执行。 5、参考http://www.cnblogs.com/coco1s/p/4833199.htmlhttps://segmentfault.com/a/1190000004568767https://segmentfault.com/a/1190000002929289http://www.cnblogs.com/coco1s/p/4833199.html","pubDate":"Fri, 02 Sep 2016 06:56:23 GMT","guid":"https://aotu.io/notes/2016/09/02/Different-Binding/","category":"Web开发"},{"title":"SeaJS从入门到原理","link":"https://aotu.io/notes/2016/08/29/SeaJs-From-Entry-To-The-Principle/","description":"最近项目中抛弃传统的&lt;script&gt;而改用 SeaJS 这样的 JS 模块加载器了，确实模块加载器对于代码的可维护性带来了较大的提升。","pubDate":"Mon, 29 Aug 2016 05:55:34 GMT","guid":"https://aotu.io/notes/2016/08/29/SeaJs-From-Entry-To-The-Principle/","category":"Web开发"}]}